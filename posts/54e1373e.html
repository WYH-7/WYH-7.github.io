<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Mysql面试题 | WYH</title><meta name="author" content="WYH"><meta name="copyright" content="WYH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="⚫ 熟悉Mysql底层存储结构，索引，事务，mvcc工作原理，学习过sql调优及分库分表优化； 事务的四大特性和隔离级别 原子性（Atomicity）原子性确保事务中的所有操作要么全部完成，要么全部不完成。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。事务是一个不可分割的最小工作单元。 例子：假设有一个银行转账操作，事务包括从账户A中扣钱和向账户B中加钱。如果任何一个操">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql面试题">
<meta property="og:url" content="http://wyh-7.github.io/posts/54e1373e.html">
<meta property="og:site_name" content="WYH">
<meta property="og:description" content="⚫ 熟悉Mysql底层存储结构，索引，事务，mvcc工作原理，学习过sql调优及分库分表优化； 事务的四大特性和隔离级别 原子性（Atomicity）原子性确保事务中的所有操作要么全部完成，要么全部不完成。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。事务是一个不可分割的最小工作单元。 例子：假设有一个银行转账操作，事务包括从账户A中扣钱和向账户B中加钱。如果任何一个操">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.pexels.com/photos/346529/pexels-photo-346529.jpeg?auto=compress&cs=tinysrgb&w=600">
<meta property="article:published_time" content="2025-04-08T14:07:51.000Z">
<meta property="article:modified_time" content="2025-05-06T05:27:20.952Z">
<meta property="article:author" content="WYH">
<meta property="article:tag" content="八股文">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.pexels.com/photos/346529/pexels-photo-346529.jpeg?auto=compress&cs=tinysrgb&w=600"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wyh-7.github.io/posts/54e1373e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#3cb371"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mysql面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-06 13:27:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="WYH" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images.pexels.com/photos/346529/pexels-photo-346529.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600')"><nav id="nav"><span id="blog-info"><a href="/" title="WYH"><span class="site-name">WYH</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Mysql面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-08T14:07:51.000Z" title="发表于 2025-04-08 22:07:51">2025-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-06T05:27:20.952Z" title="更新于 2025-05-06 13:27:20">2025-05-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mysql面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>⚫ 熟悉Mysql底层存储结构，索引，事务，mvcc工作原理，学习过sql调优及分库分表优化；</p>
<h1 id="事务的四大特性和隔离级别"><a href="#事务的四大特性和隔离级别" class="headerlink" title="事务的四大特性和隔离级别"></a>事务的四大特性和隔离级别</h1><blockquote>
<h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>原子性确保事务中的所有操作<strong>要么全部完成，要么全部不完成</strong>。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。事务是一个不可分割的最小工作单元。</p>
<p><strong>例子</strong>：假设有一个银行转账操作，事务包括从账户A中扣钱和向账户B中加钱。如果任何一个操作失败，整个事务都会回滚，账户A和账户B的余额不会发生变化。</p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一致性确保事务在完成后，数据库<strong>从一个一致状态转换到另一个一致状态</strong>。事务开始前和结束后，数据库的完整性约束没有被破坏。</p>
<p><strong>例子</strong>：在银行转账操作中，一致性确保转账后总金额保持不变。如果账户A减少了100元，账户B就应该增加100元。</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>隔离性确保<strong>并发执行的事务彼此隔离开来</strong>，避免相互干扰。不同的事务之间的操作是互不可见的，直到事务提交。</p>
<p><strong>例子</strong>：还是上面的银行转账操作，a 正在银行扣 100 块的时候，b 不能往里面加 100 块。</p>
<p><strong>隔离级别</strong>：</p>
<ol>
<li><strong>读未提交（Read Uncommitted）</strong>：<strong>一个事务可以读到另一个未提交事务的数据</strong>，可能导致脏读。</li>
</ol>
<p><strong>脏读</strong>：一个事务读取了另一个事务未提交的数据。<strong>如果该事务回滚，那么读到的数据将是无效的</strong>。</p>
<p>例如：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。</p>
<ol>
<li><strong>读已提交（Read Committed）</strong>：<strong>一个事务只能读到已提交事务的数据</strong>，避免脏读,但可能会出现不可重复读。</li>
</ol>
<p><strong>不可重复读</strong>：一个事务在读取同一行数据时，可能<strong>因为另一个事务的提交而得到不同的结果</strong>。</p>
<p>例如：在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p>
<ol>
<li><strong>可重复读（Repeatable Read）</strong>：<strong>一个事务在整个过程中看到的数据是一致的</strong>，避免不可重复读，但可能会出现幻读。</li>
</ol>
<p><strong>幻读</strong>：一个事务在读取某个范围内的行时，另一个事务在该范围内插入了新的行，导致前一个事务再次读取时发现了“幻影”行。</p>
<p>例如：目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p>
<p><strong>不可重复读</strong>的重点是<strong>修改</strong>：同样的条件，你读取过的数据，再次读取出来发现值不一样了。</p>
<p><strong>幻读</strong>的重点在于<strong>新增或者删除</strong>：同样的条件，第 1 次和第 2 次读出来的记录数不一样。</p>
<ol>
<li><strong>串行化（Serializable）</strong>：最高隔离级别，事务完全串行化执行，避免幻读，代价是并发性大大降低，事务可能会因为锁等待而阻塞。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>隔离级别</strong></th>
<th style="text-align:center"><strong>脏读</strong></th>
<th style="text-align:center"><strong>不可重复读</strong></th>
<th style="text-align:center"><strong>幻读</strong></th>
<th style="text-align:center"><strong>原理</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read uncommitted (读未提交)</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">直接读取数据，不处理并发问题</td>
</tr>
<tr>
<td style="text-align:center">Read committed (读已提交)</td>
<td style="text-align:center">×</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">读操作不加锁，写操作加排他锁</td>
</tr>
<tr>
<td style="text-align:center">Repeatable read (可重复读)</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">MVCC实现，事务开始时创建ReadView，之后事务的其他查询都用这个ReadView</td>
</tr>
<tr>
<td style="text-align:center">Serializable (串行化)</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">使用锁，读加共享锁，写加排他锁，串行执行</td>
</tr>
</tbody>
</table>
</div>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>持久性确保<strong>事务一旦提交，其结果是永久性的</strong>，即使系统发生故障，数据也不会丢失。</p>
<p><strong>例子</strong>：在银行转账操作中，一旦事务提交，转账操作的结果（账户A和账户B的余额变化）将永久保存在数据库中，即使之后系统崩溃，数据也不会丢失。</p>
</blockquote>
<h1 id="MyISAM与InnoDB区别及选择"><a href="#MyISAM与InnoDB区别及选择" class="headerlink" title="MyISAM与InnoDB区别及选择"></a>MyISAM与InnoDB区别及选择</h1><blockquote>
<h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p><strong>MyISAM</strong> 将<strong>数据</strong>存储在<strong>三个文件</strong>中（.frm文件存储表结构，.MYD文件存储数据，.MYI文件存储索引）；</p>
<p><strong>InnoDB</strong> 将<strong>数据和索引</strong>存储在<strong>表空间文件</strong>中，支持自动扩展和多表空间。（.frm文件存储表结构定义，.ibd存储数据和索引）</p>
<p>由于MyISAM的数据和索引是分开存储的，所以查询的时候，<strong>MyISAM</strong>的<strong>叶子节点</strong>存储的是数据所在的<strong>地址</strong>，而不是直接存储数据。</p>
<h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p><strong>MyISAM</strong> <strong>不支持事务</strong>，无法进行回滚和提交操作</p>
<p><strong>InnoDB</strong> 支持事务，提供 ACID 特性（原子性、一致性、隔离性、持久性）。</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p><strong>MyISAM</strong> 使用<strong>表级锁</strong>，每次操作都会锁定整个表，适合读多写少的应用</p>
<p><strong>InnoDB</strong> 使用<strong>行级锁</strong>，每次操作只锁定相关的行，适合高并发和写操作频繁的应用。</p>
<h3 id="外键支持"><a href="#外键支持" class="headerlink" title="外键支持"></a>外键支持</h3><p><strong>MyISAM</strong> <strong>不支持外键</strong>，无法在表间建立引用完整性约束</p>
<p><strong>InnoDB</strong> 支持外键，可以在表间建立引用完整性约束，保证数据的一致性和完整性。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p><strong>MyISAM</strong> 原生<strong>支持全文索引</strong>，适合需要全文搜索的应用</p>
<p><strong>InnoDB</strong> 从 MySQL 5.6 开始支持全文索引，但性能和功能上仍不如 MyISAM。</p>
<h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><p><strong>MyISAM</strong> 存储空间效率较高，数据文件较小</p>
<p><strong>InnoDB</strong> 可能占用更多存储空间，特别是需要存储事务日志和外键约束信息。</p>
<h3 id="表的大小限制"><a href="#表的大小限制" class="headerlink" title="表的大小限制"></a>表的大小限制</h3><p><strong>MyISAM</strong> 受文件系统限制，单个表最大<strong>可达 256TB</strong>（取决于文件系统）</p>
<p><strong>InnoDB</strong> 最大<strong>表大小可达 64TB</strong>，适合处理大规模数据集。</p>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>1、 需要事务支持必选InnoDB，不需要事务选择MyISAM</p>
<p>2、如果表的大部分操作都是查询，数据不大，并发不大，可以考虑选择MyISAM，但是一般还是选择 innodb，有写又有读则选择InnoDB</p>
<p>3、如果系统奔溃导致数据难以恢复，且成本高，选择 innodb</p>
</blockquote>
<h1 id="自适应hash索引"><a href="#自适应hash索引" class="headerlink" title="自适应hash索引"></a>自适应hash索引</h1><blockquote>
<p><strong>自适应哈希索引</strong>是InnoDB存储引擎的一项独特<strong>性能优化特性</strong>，旨在针对高频访问的热点数据提升查询效率。与传统的静态哈希索引不同，自适应哈希索引采纳了一种<strong>自动化、动态调整</strong>的机制：InnoDB<strong>自主监控查询模式及数据访问频次</strong>，据此智能决策哈希索引的创建与否，并能依据数据集变动及查询模式的演进灵活地调整索引结构，无需人工介入。<br>其运作<strong>原理</strong>如下：当InnoDB检测到特定索引键值频繁遭受等值查询操作，系统便会在内存中自发为这些热点键值生成哈希索引，以此来加速后续的等值查询响应时间。这一系列优化行为均在后台自动执行，无需用户的直接参与或配置。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>自动优化：自适应哈希索引会自己悄悄地建立和打理，你不需要专门去做什么或者管它。<br>性能提升：在找一些特定相同值的时候，这个自适应哈希索引能大大加快寻找速度，它的查找速度超级快，差不多是瞬间完成的（专业点说就是查询时间是<strong>O(1)</strong>）。<br>省资源：它还减少了去二级索引树那里找信息的次数，这样就节约了系统资源。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>内存消耗</strong>： 自适应哈希索引完全在内存中构建，需要足够的内存资源。</p>
<p><strong>不可预测性</strong>：由于是基于运行时查询模式的，所以哈希索引的存在和组成是不可预测的。</p>
<p><strong>不适用于所有查询</strong>：自适应哈希索引主要<strong>优化等值查询</strong>，对于<strong>范围查询或排序操作没有帮助</strong>。</p>
<p><strong>hash自适应索引会占用innodb buffer pool；</strong></p>
<p>总的来说，自适应哈希索引是 InnoDB 存储引擎为了提高特定类型查询性能而自动构建的一种内存中的哈希索引结构。它可以根据查询模式和数据访问频率自动调整，以优化数据库的性能。</p>
</blockquote>
<h1 id="Mysql使用规范"><a href="#Mysql使用规范" class="headerlink" title="Mysql使用规范"></a>Mysql使用规范</h1><blockquote>
<h3 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h3><p><strong>范式化设计</strong>：根据业务需求，合理选择符合一定范式（如1NF、2NF、3NF或BCNF）进行表结构设计，减少数据冗余，保证数据的一致性。</p>
<p><strong>表命名规范</strong>：采用有意义的、区分大小写的表名，通常使用小写字母，并用下划线<code>_</code>分隔单词，如<code>user_info</code>。</p>
<p><strong>字段命名规范</strong>：同样遵循有意义的命名原则，使用小写字母加下划线，避免使用数据库保留字。</p>
<h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><p><strong>适度索引</strong>：为频繁查询和参与JOIN操作的字段创建索引，但需注意过多的索引会影响插入、删除和更新操作的性能。</p>
<p><strong>索引类型选择</strong>：根据数据特性和查询需求选择合适的索引类型，如<strong>BTREE索引适用于范围查询，哈希索引适合等值查询</strong>。</p>
<p><strong>复合索引</strong>：合理安排复合索引中字段的顺序，一般<strong>将区分度高的字段放在前面以提高索引利用率</strong>。</p>
<h3 id="SQL编写规范"><a href="#SQL编写规范" class="headerlink" title="SQL编写规范"></a>SQL编写规范</h3><p><strong>避免SELECT *</strong>：明确指定需要查询的字段，减少不必要的数据传输量。</p>
<p><strong>使用参数化查询</strong>：防止SQL注入攻击，提高代码安全性和可读性。</p>
<p><strong>事务处理</strong>：对相关操作使用事务管理，确保数据一致性，尤其是在涉及多表操作时。</p>
<h3 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h3><p>根据实际存储需求选择最合适的的数据类型，避免过度使用大容量类型，比如合理使用<code>INT</code>而非<code>BIGINT</code>，使用<code>VARCHAR</code>并限制长度而非无限制的<code>TEXT</code>。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p><strong>定期分析和优化表</strong>：使用<code>ANALYZE TABLE</code>和<code>OPTIMIZE TABLE</code>命令来分析表的状态并进行必要的优化。</p>
<p><strong>查询优化</strong>：利用<code>EXPLAIN</code>分析查询计划，优化复杂的查询语句，<strong>减少子查询</strong>的使用，适当情况下使<strong>用连接（JOIN）代替</strong>。</p>
<p>定期进行数据库备份，包括全备和增量备份，确保在数据丢失或损坏时能够快速恢复。</p>
<h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><p><strong>最小权限原则</strong>：为不同用户或应用分配仅满足其功能所需的最小权限。</p>
<p><strong>加密敏感数据</strong>：对敏感信息如密码进行加密存储，不直接保存明文。</p>
<h3 id="监控与日志"><a href="#监控与日志" class="headerlink" title="监控与日志"></a>监控与日志</h3><p>启用并监控MySQL的日志系统（如错误日志、慢查询日志），及时发现并解决问题。<br>遵循这些规范，可以帮助开发团队构建更加健壮、高效、易于维护的MySQL数据库应用系统。</p>
</blockquote>
<h1 id="建立索引需要考虑的因素"><a href="#建立索引需要考虑的因素" class="headerlink" title="建立索引需要考虑的因素"></a>建立索引需要考虑的因素</h1><blockquote>
<h3 id="选择合适的列"><a href="#选择合适的列" class="headerlink" title="选择合适的列"></a>选择合适的列</h3><p>并非所有列都适合创建索引。通常，那些频繁用于查询条件（如WHERE子句）、JOIN操作或者ORDER BY、GROUP BY语句中的列是建立索引的首选。同时，考虑到索引维护的成本，应<strong>避免</strong>在具有<strong>高更新频率或大量重复值的列</strong>上建立索引。</p>
<h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果一个查询的所有需要的数据都能从索引中直接获取而<strong>无需回表查询</strong>（即<strong>索引覆盖查询</strong>），那么这样的查询将更加高效。因此，在设计索引时，考虑是否能通过包含额外的列来实现索引覆盖。</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>根据数据特性和查询需求选择合适的索引类型。例如，<strong>B-Tree索引</strong>是最常见的，适用于<strong>范围查询和等于操作</strong>；<strong>哈希索引</strong>适合<strong>等值查询</strong>；<strong>位图索引</strong>在数据只有<strong>几种固定值</strong>时效率较高；而<strong>全文索引</strong>则用于<strong>文本的全文搜索</strong>。</p>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>当查询涉及多个列时，可以考虑创建<strong>复合索引</strong>（即<strong>包含多个列的索引</strong>）。合理安排复合索引中列的顺序至关重要，一般将区分度高的列放在前面以提高筛选效率。</p>
<h3 id="索引的稀疏性"><a href="#索引的稀疏性" class="headerlink" title="索引的稀疏性"></a>索引的稀疏性</h3><p>索引应该尽可能地“瘦”，即只包含对查询有帮助的列，避免不必要的数据冗余，减少索引的大小和维护成本。</p>
<h3 id="系统资源与性能影响"><a href="#系统资源与性能影响" class="headerlink" title="系统资源与性能影响"></a>系统资源与性能影响</h3><p>创建和维护索引会占用磁盘空间，并可能影响数据插入、删除和更新的性能。需要权衡索引带来的查询加速与资源消耗之间的平衡，尤其是在数据量大、写操作频繁的场景下。索引会占用额外的存储空间，特别是对大表和多列索引，需要权衡存储成本。</p>
<h3 id="评估和优化"><a href="#评估和优化" class="headerlink" title="评估和优化"></a>评估和优化</h3><p>随着业务需求和数据量的变化，定期评估现有索引的有效性，删除不再使用的索引，添加新的索引。使用数据库的监控工具（如 MySQL 的慢查询日志、性能模式等）监控索引的使用情况和性能。</p>
</blockquote>
<h1 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h1><blockquote>
<p>数据库设计中的三范式（3NF）是关系数据库理论中的一种规范化标准，用于<strong>减少数据冗余和提高数据一致性</strong>。</p>
<h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 (1NF)"></a>第一范式 (1NF)</h3><p>第一范式要求每个表中的字段值都是原子的，即<strong>每个字段只能包含一个值，不能包含重复的组或数组</strong>。</p>
<ol>
<li>每个列中的值必须是不可分割的原子值。</li>
<li>表中的每一行必须是唯一的，即每一行都应该有一个唯一的标识符（通常是主键）。</li>
</ol>
<h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 (2NF)"></a>第二范式 (2NF)</h3><p>第二范式在满足第一范式的基础上，要求表中的<strong>每个非主键字段必须完全依赖于主键</strong>，消除部分依赖。</p>
<ol>
<li>表必须满足第一范式。</li>
<li>非主键字段必须完全依赖于主键，而不能只依赖于主键的一部分（如果主键是复合主键）。</li>
</ol>
<h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 (3NF)"></a>第三范式 (3NF)</h3><p>第三范式在满足第二范式的基础上，要求表中的<strong>非主键字段之间不能有传递依赖</strong>。</p>
<ol>
<li>表必须满足第二范式。</li>
<li>非主键字段之间不能存在传递依赖，即<strong>非主键字段必须直接依赖于主键</strong>，而不能通过其他非主键字段间接依赖于主键。</li>
</ol>
</blockquote>
<h1 id="Mysql的explain有哪些列"><a href="#Mysql的explain有哪些列" class="headerlink" title="Mysql的explain有哪些列"></a>Mysql的explain有哪些列</h1><blockquote>
<p>EXPLAIN命令用于<strong>分析 SQL 查询的执行计划</strong>，帮助优化查询性能。通过 explain 命令获取 select 语句的执行计划，通过 explain 我们可以知道以下信息：<code>表的读取顺序，数据读取操作的类型，哪些索引可以使用，哪些索引实际使用了，表之间的引用，每张表有多少行被优化器查询</code>等信息。</p>
<h3 id="idM"><a href="#idM" class="headerlink" title="idM"></a>idM</h3><p>查询的标识符。一个查询中的每个子查询或联合查询都会有一个唯一的id。id相同时，执行顺序由上至下。如果是子查询，id的序号会递增，<strong>id值越大优先级越高</strong>，越先被执行。id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行。主要用于区分查询中的不同部分。</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>查询的类型，描述 SELECT 的类型。</p>
<p><strong>常见值</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;SIMPLE：简单的 SELECT 查询，不包含子查询或 UNION。</span><br><span class="line">&gt;PRIMARY：最外层的 SELECT。</span><br><span class="line">&gt;UNION：UNION 中的第二个或后续的 SELECT 查询。</span><br><span class="line">&gt;DEPENDENT UNION：UNION 中的第二个或后续的 SELECT 查询，依赖于外部查询。</span><br><span class="line">&gt;UNION RESULT：UNION 的结果。</span><br><span class="line">&gt;SUBQUERY：子查询中的第一个 SELECT。</span><br><span class="line">&gt;DEPENDENT SUBQUERY：子查询，依赖于外部查询。</span><br><span class="line">&gt;DERIVED：派生表（子查询的结果作为临时表）。</span><br></pre></td></tr></table></figure>
<p>当通过union来连接多个查询结果时，第二个之后的select其select_type为UNION。</p>
<p>当union作为<strong>子查询</strong>时，其中第二个union的select_type就是DEPENDENT UNION。第一个子查询的select_type则是DEPENDENT SUBQUERY。</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>这一列表示 explain的<strong>这一行正在访问哪个表</strong>。</p>
<p>1）当 from 子句中有子查询时，如果table列是 <code>&lt;derivenN&gt;</code> 格式，则表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。</p>
<p>2）当有 union 时，UNION RESULT 的 table 列的值为<union1,2>，1和2表示参与 union 的 select 行id。</union1,2></p>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>如果该查询是<strong>基于分区表的查询</strong>，partitions字段会显示查询所访问的分区。</p>
<h3 id="type-重点"><a href="#type-重点" class="headerlink" title="type(重点)"></a>type(重点)</h3><p>这一列表示<strong>关联类型或访问类型</strong>，即，Mysql决定通过哪种方式查找数据表中的数据。</p>
<p>从优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong></p>
<p>一般来说，至少需要保证查询达到range级别，最好达到ref级别。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">system</td>
<td style="text-align:left">表只有一行（等于系统表）</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:left">表最多有一行匹配</td>
</tr>
<tr>
<td style="text-align:center">eq_ref</td>
<td style="text-align:left">对于每个来自前一个表的行，最多一行与之匹配，比如一个订单表的对应另一张订单信息扩充表，扩充表的记录和订单表肯定是 1 对 1 的，就是 eq</td>
</tr>
<tr>
<td style="text-align:center">ref</td>
<td style="text-align:left">对于每个来自前一个表的行，可能有多行与之匹配，如果上面的例子是一对多，那么就是 ref</td>
</tr>
<tr>
<td style="text-align:center">range</td>
<td style="text-align:left">使用索引查找指定范围的行</td>
</tr>
<tr>
<td style="text-align:center">index</td>
<td style="text-align:left">全索引扫描，扫描索引树</td>
</tr>
<tr>
<td style="text-align:center">ALL</td>
<td style="text-align:left">全表扫描</td>
</tr>
</tbody>
</table>
</div>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>指出MySQL能<strong>使用哪个索引在表中找到记录</strong>，查询涉及到的字段上若存在索引，则该索引将被列出，但<strong>不一定被使用</strong>（该查询可以利用的索引，如果没有任何索引显示 null）</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key列显示MySQL<strong>实际决定使用的键（索引）</strong>，必然包含在possible_keys中</p>
<p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>
<p>可能出现这种情况，possible_keys有显示列，而key显示NULL的情况，这种情况是因为表中数据不多，Mysql优化器认为查询时走索引对此查询语句帮助不大，从而优化器会选择全表扫描（扫描聚簇索引），而不是走索引来查询。</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>显示MySQL认为它执行查询时检查的行数。多行之间的同组数据相乘可以估算要处理的行数，不同组的相加</p>
<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>该列是一个百分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>附加信息。</p>
<p><strong>Using index</strong>：查询使用了覆盖索引（索引包含所有需要的数据）。</p>
<p><strong>Using where</strong>：使用了WHERE子句进行过滤。</p>
<p><strong>Using temporary</strong>：使用了临时表。</p>
<p><strong>Using filesort</strong>：使用了文件排序。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们有一个电子商务数据库，包含以下两个表：</p>
<ol>
<li>orders表：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">   order_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   customer_id <span class="type">INT</span>,</span><br><span class="line">   order_date <span class="type">DATE</span>,</span><br><span class="line">   total_amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol>
<li>customers表：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">   customer_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   customer_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">   email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line"><span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure>
<p>我们有一个查询，想要获取在特定日期范围内下单的客户信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> c.customer_name, c.email, o.order_date, o.total_amount <span class="keyword">FROM</span> orders o <span class="keyword">JOIN</span> customers c <span class="keyword">ON</span> o.customer_id <span class="operator">=</span> c.customer_id <span class="keyword">WHERE</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-01-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用-EXPLAIN-分析查询"><a href="#使用-EXPLAIN-分析查询" class="headerlink" title="使用 EXPLAIN 分析查询"></a>使用 EXPLAIN 分析查询</h3><p>执行EXPLAIN命令来分析这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span>EXPLAIN <span class="keyword">SELECT</span> c.customer_name, c.email, o.order_date, o.total_amount <span class="keyword">FROM</span> orders o <span class="keyword">JOIN</span> customers c <span class="keyword">ON</span> o.customer_id <span class="operator">=</span> c.customer_id <span class="keyword">WHERE</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-01-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="EXPLAIN-输出示例"><a href="#EXPLAIN-输出示例" class="headerlink" title="EXPLAIN 输出示例"></a>EXPLAIN 输出示例</h3><p>假设EXPLAIN返回以下结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>o</td>
<td>NULL</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>10000</td>
<td>10.00</td>
<td>Using where</td>
</tr>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>c</td>
<td>NULL</td>
<td>eq_ref</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>4</td>
<td>e_commerce.o.customer_id</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
</tbody>
</table>
</div>
<h3 id="分析-EXPLAIN-输出"><a href="#分析-EXPLAIN-输出" class="headerlink" title="分析 EXPLAIN 输出"></a>分析 EXPLAIN 输出</h3><h3 id="orders-表扫描（o-表）"><a href="#orders-表扫描（o-表）" class="headerlink" title="orders 表扫描（o 表）"></a>orders 表扫描（o 表）</h3><p><strong>type</strong>: ALL表示全表扫描，这意味着 MySQL 需要扫描orders表的所有行。</p>
<p><strong>possible_keys</strong>:NULL表示没有可用的索引。</p>
<p><strong>rows</strong>: 10000 表示 MySQL 估计需要扫描 10,000 行。</p>
<p><strong>Extra</strong>:Using where表示 MySQL 使用了WHERE子句来过滤行。</p>
<h3 id="customers-表扫描（c-表）"><a href="#customers-表扫描（c-表）" class="headerlink" title="customers 表扫描（c 表）"></a>customers 表扫描（c 表）</h3><p><strong>type</strong>:eq_ref表示对customer_id列的精确查找。</p>
<p><strong>key</strong>:PRIMARY表示使用了customers表的主键索引。</p>
<p><strong>rows</strong>: 1 表示每次查找只返回一行。</p>
<h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p><strong>为orders表的order_date列创建索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">CREATE</span> INDEX idx_order_date <span class="keyword">ON</span> orders(order_date);</span><br></pre></td></tr></table></figure>
<p><strong>再次运行 EXPLAIN</strong>查看效果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span>EXPLAIN <span class="keyword">SELECT</span> c.customer_name, c.email, o.order_date, o.total_amount <span class="keyword">FROM</span> orders o <span class="keyword">JOIN</span> customers c <span class="keyword">ON</span> o.customer_id <span class="operator">=</span> c.customer_id <span class="keyword">WHERE</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-01-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="优化后的-EXPLAIN-输出示例"><a href="#优化后的-EXPLAIN-输出示例" class="headerlink" title="优化后的 EXPLAIN 输出示例"></a>优化后的 EXPLAIN 输出示例</h3><div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>o</td>
<td>NULL</td>
<td>range</td>
<td>idx_order_date</td>
<td>idx_order_date</td>
<td>3</td>
<td>NULL</td>
<td>1000</td>
<td>100.00</td>
<td>Using index</td>
</tr>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>c</td>
<td>NULL</td>
<td>eq_ref</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>4</td>
<td>e_commerce.o.customer_id</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
</tbody>
</table>
</div>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><h3 id="orders-表扫描（o-表）-1"><a href="#orders-表扫描（o-表）-1" class="headerlink" title="orders 表扫描（o 表）"></a>orders 表扫描（o 表）</h3><p><strong>type</strong>:range表示使用索引扫描特定范围的行。</p>
<p><strong>key</strong>:idx_order_date表示使用了新创建的索引。</p>
<p><strong>rows</strong>: 1000 表示 MySQL 估计需要扫描 1,000 行，而不是之前的 10,000 行。</p>
<p>通过创建索引，查询性能得到了显著提升，因为 MySQL 不再需要对orders表进行全表扫描，而是使用索引快速定位符合条件的行。</p>
</blockquote>
<h1 id="Mysql语句种类"><a href="#Mysql语句种类" class="headerlink" title="Mysql语句种类"></a>Mysql语句种类</h1><blockquote>
<h3 id="数据定义语言-DDL"><a href="#数据定义语言-DDL" class="headerlink" title="数据定义语言 (DDL)"></a>数据定义语言 (DDL)</h3><p>DDL 语句用于定义和管理数据库结构，例如创建、修改和删除数据库和表。</p>
<p><strong>CREATE</strong>：创建数据库、表、索引等。</p>
<p><strong>ALTER</strong>：修改现有数据库对象的结构。</p>
<p><strong>DROP</strong>：删除数据库、表、索引等。</p>
<p><strong>TRUNCATE</strong>：清空表中的所有数据，但保留表结构。</p>
<h3 id="数据操作语言-DML"><a href="#数据操作语言-DML" class="headerlink" title="数据操作语言 (DML)"></a>数据操作语言 (DML)</h3><p>DML 语句用于操作数据库中的数据，例如插入、更新、删除和查询数据。</p>
<p><strong>INSERT</strong>：插入数据。</p>
<p><strong>UPDATE</strong>：更新数据。</p>
<p><strong>DELETE</strong>：删除数据。</p>
<p><strong>SELECT</strong>：查询数据。</p>
<h3 id="数据控制语言-DCL"><a href="#数据控制语言-DCL" class="headerlink" title="数据控制语言 (DCL)"></a>数据控制语言 (DCL)</h3><p>DCL 语句用于控制数据库的访问权限。</p>
<p><strong>GRANT</strong>：授予用户权限。</p>
<p><strong>REVOKE</strong>：撤销用户权限。</p>
<h3 id="事务控制语言-TCL"><a href="#事务控制语言-TCL" class="headerlink" title="事务控制语言 (TCL)"></a>事务控制语言 (TCL)</h3><p>TCL 语句用于管理事务，确保数据的一致性和完整性。</p>
<p><strong>START TRANSACTION</strong>：开始一个事务。</p>
<p><strong>COMMIT</strong>：提交事务。</p>
<p><strong>ROLLBACK</strong>：回滚事务。</p>
<p><strong>SAVEPOINT</strong>：设置保存点。</p>
<p><strong>RELEASE SAVEPOINT</strong>：释放保存点。</p>
<p><strong>ROLLBACK TO SAVEPOINT</strong>：回滚到保存点。</p>
<h3 id="数据查询语言-DQL"><a href="#数据查询语言-DQL" class="headerlink" title="数据查询语言 (DQL)"></a>数据查询语言 (DQL)</h3><p>DQL 主要包括SELECT语句，用于查询数据库中的数据。</p>
<p><strong>SELECT</strong>：查询数据。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>EXPLAIN</strong>：解释查询执行计划。</p>
<p><strong>SHOW</strong>：显示数据库对象的信息。</p>
<p><strong>DESCRIBE</strong>：显示表的结构。</p>
</blockquote>
<h1 id="Mysql查询优化"><a href="#Mysql查询优化" class="headerlink" title="Mysql查询优化"></a>Mysql查询优化</h1><blockquote>
<h3 id="避免全表扫描"><a href="#避免全表扫描" class="headerlink" title="避免全表扫描"></a>避免全表扫描</h3><p>优化查询时，应避免全表扫描，优先在 WHERE 和 ORDER BY 涉及的列上建立索引。</p>
<h3 id="避免-NULL-值判断"><a href="#避免-NULL-值判断" class="headerlink" title="避免 NULL 值判断"></a>避免 NULL 值判断</h3><p><strong>避免在 WHERE 子句中对字段进行 NULL 值判断</strong>。创建表时，尽量使用 NOT NULL 或使用特殊值（如 0 或 -1）作为默认值。</p>
<p>Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。</p>
<p>还有几点原因：</p>
<p>1、所有使用NULL值的情况，都可以通过一个有意义的值的表示，这样有利于代码的可读性和可维护性，并能从约束上增强业务数据的规范性。</p>
<p>2、NULL值到非NULL的更新无法做到原地更新，更容易发生索引分裂，从而影响性能。</p>
<p>3、NOT IN、!= 等负向条件查询在有 NULL 值的情况下返回永远为空结果，查询容易出错</p>
<h3 id="避免-或-lt-gt-操作符"><a href="#避免-或-lt-gt-操作符" class="headerlink" title="避免 != 或 &lt;&gt; 操作符"></a>避免 != 或 &lt;&gt; 操作符</h3><p>避免在 WHERE 子句中使用 != 或 &lt;&gt; 操作符。MySQL 仅对 &lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 以及某些情况下的 LIKE 使用索引。</p>
<h3 id="避免-OR-条件"><a href="#避免-OR-条件" class="headerlink" title="避免 OR 条件"></a>避免 OR 条件</h3><p>避免在 WHERE 子句中使用 OR 连接条件，因这会导致全表扫描。可以使用 <strong>UNION 合并查询</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;SELECT id FROM t WHERE num=10 UNION ALL SELECT id FROM t WHERE num=20;</span><br></pre></td></tr></table></figure>
<h3 id="谨慎使用-IN-和-NOT-IN"><a href="#谨慎使用-IN-和-NOT-IN" class="headerlink" title="谨慎使用 IN 和 NOT IN"></a>谨慎使用 IN 和 NOT IN</h3><p>谨慎使用 IN 和 NOT IN，因其可能导致全表扫描。对于连续数值，用 <strong>BETWEEN 替代</strong> IN：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> num <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="LIKE-查询优化"><a href="#LIKE-查询优化" class="headerlink" title="LIKE 查询优化"></a>LIKE 查询优化</h3><p>避免使用%abc%或%abc的 LIKE 查询，这会导致全表扫描。可以考虑<strong>使用全文检索</strong>。只有abc%的 LIKE 查询会使用索引。</p>
<h3 id="避免参数化查询导致的全表扫描"><a href="#避免参数化查询导致的全表扫描" class="headerlink" title="避免参数化查询导致的全表扫描"></a>避免参数化查询导致的全表扫描</h3><p>避免在 WHERE 子句中使用参数，这会导致全表扫描。可以<strong>强制查询使用索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WITH</span> (INDEX(索引名)) <span class="keyword">WHERE</span> num<span class="operator">=</span><span class="variable">@num</span>;</span><br></pre></td></tr></table></figure>
<h3 id="避免表达式操作"><a href="#避免表达式操作" class="headerlink" title="避免表达式操作"></a>避免表达式操作</h3><p>避免在 WHERE 子句中对字段进行函数操作。</p>
<p>不要<code>WHERE YEAR(order_date) = 2024</code>使用 ，而要使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">WHERE</span> order_date <span class="operator">&gt;=</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> order_date <span class="operator">&lt;</span> <span class="string">&#x27;2025-01-01&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-EXISTS-替代-IN"><a href="#使用-EXISTS-替代-IN" class="headerlink" title="使用 EXISTS 替代 IN"></a>使用 EXISTS 替代 IN</h3><p>使用 EXISTS 替代 IN，可以提高查询效率：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> num <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> b <span class="keyword">WHERE</span> num<span class="operator">=</span>a.num);</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Mysql聚集索引"><a href="#Mysql聚集索引" class="headerlink" title="Mysql聚集索引"></a>Mysql聚集索引</h1><blockquote>
<p>MySQL 中的聚集索引是指<strong>数据表的记录按照索引的顺序进行物理存储</strong>。也就是说，表中的数据行和索引行一起存储，并且数据行的顺序与索引的顺序相同。聚集索引的特点是<strong>索引的叶节点包含了实际的数据行</strong>。<strong>一个表中只能有一个聚集索引</strong>，因为只能以一种物理顺序存放。</p>
<p>在 MySQL 中，<strong>InnoDB 存储引擎默认使用聚集索引</strong>。InnoDB 表必须有一个聚集索引，如果没有显式定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>作为聚集索引。如果没有这样的索引，InnoDB 会自动生成一个名为<strong>row_id隐藏的聚集索引</strong>。</p>
<p>我们通过InnoDB把数据存放到B+树中，而B+树中的键值就是主键，那么在B+树中的叶子节点存储的就是表中的所有数据（即该主键对应的整行数据），数据文件和索引文件是同一个文件，找到了索引便找到了数据，所以称之为聚集索引。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>物理顺序存储</strong>：数据行按照索引键的顺序存储在数据页中。</li>
<li><strong>叶节点包含数据</strong>：聚集索引的叶节点包含了实际的数据行。</li>
<li><strong>只能有一个</strong>：每个数据表只能有一个聚集索引，因为数据行只能按一种顺序存储。</li>
</ol>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>查询效率高</strong>：对于基于聚集索引的范围查询（between、&lt;、&lt;=、&gt;、&gt;=）和排序操作（group by、order by），效率较高，因为数据行是按索引顺序存储的。因为聚集索引找到包含第一个值的行后，后续索引值的行在物理上毗连在一起而不必进一步搜索，避免大范围扫描，大大提高查询速度。</li>
<li><strong>覆盖索引</strong>：在某些查询中，聚集索引可以充当覆盖索引，从而减少读取数据的次数。</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>插入速度较慢：在插入新记录时，可能需要移动大量数据行以保持索引顺序。</li>
<li>更新代价高：更新聚集索引键值时，可能导致数据行的重新排序。移动行可能还会面临页分裂问题（即页已满），存储引擎会将该页分裂成两个页面来容纳，页分裂会占用更多磁盘空间。即索引重排，造成资源浪费。</li>
<li>占用更多存储空间：由于数据行和索引一起存储，可能占用更多的存储空间。</li>
</ol>
</blockquote>
<h1 id="聚集索引不要选择频繁更新的列"><a href="#聚集索引不要选择频繁更新的列" class="headerlink" title="聚集索引不要选择频繁更新的列"></a>聚集索引不要选择频繁更新的列</h1><blockquote>
<h3 id="数据重排"><a href="#数据重排" class="headerlink" title="数据重排"></a>数据重排</h3><p>由于聚集索引的特点是数据行按照索引键的顺序进行物理存储，当聚集索引键的值发生变化时，数据库需要将该行移动到新的位置以保持索引顺序。这种数据重排操作会消耗大量的 I/O 和 CPU 资源，导致性能下降。</p>
<h3 id="页分裂和合并"><a href="#页分裂和合并" class="headerlink" title="页分裂和合并"></a>页分裂和合并</h3><p>当新的数据行插入到现有页面中而页面已经满了时，InnoDB 需要进行页分裂（Page Split），将一个页面分成两个页面，以腾出空间存储新数据。这种操作不仅耗时，还会导致磁盘碎片，影响查询性能。频繁更新聚集索引键会增加页分裂的频率。</p>
<h3 id="二级索引的维护"><a href="#二级索引的维护" class="headerlink" title="二级索引的维护"></a>二级索引的维护</h3><p>InnoDB 中的二级索引会引用聚集索引的键作为指向数据行的指针。当聚集索引键发生变化时，所有引用该键的二级索引也需要更新。这会增加额外的维护成本，影响整体性能。</p>
<h3 id="锁争用和死锁"><a href="#锁争用和死锁" class="headerlink" title="锁争用和死锁"></a>锁争用和死锁</h3><p>频繁更新聚集索引键可能导致更多的锁争用和死锁问题。数据行的移动和页分裂操作需要持有独占锁，这会阻塞其他事务的读写操作，增加系统的锁争用和死锁风险。</p>
</blockquote>
<h1 id="Mysql非聚集索引"><a href="#Mysql非聚集索引" class="headerlink" title="Mysql非聚集索引"></a>Mysql非聚集索引</h1><blockquote>
<p>MySQL 的非聚集索引（Non-Clustered Index），也称为<strong>辅助索引或二级索引</strong>，是指索引的叶节点不包含实际的数据行，而是包含指向数据行的指针（通常是聚集索引键）。通俗理解，以主键以外的列作为键值构建的B+树索引。非聚集索引的主要作用是<strong>加速特定列上的查询操作，而不改变数据行的物理存储顺序</strong>。记录的物理顺序与逻辑顺序没有必然的联系。</p>
<p>非聚集索引表数据存储顺序与索引数据无关，<strong>叶节点包含索引字段值及指向数据页数据行的逻辑指针</strong>（其行数量与数据表数据量相同），所以想要查找数据还需要根据主键再去聚集索引中查找，根据聚集索引查找数据的过程就称为<strong>回表</strong>。</p>
<p>一个表中可以拥有多个非聚集索引。实际上每个表最多可以建立249个非聚集索引，但是每次给字段建一个新索引，字段中的数据就会被复制出来一份用于生成索引，因此给表添加索引会增加表的体积，占据大量磁盘空间和内存。所以若磁盘空间和内存有限，应限制非聚集索引数量。每当你改变了一个建立非聚集索引的表中数据时，必须同时更新索引，所以非聚集索引会降低插入和更新速度。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>独立于数据存储顺序</strong>：非聚集索引不会改变数据行的物理存储顺序，数据行的顺序由聚集索引决定。</li>
<li><strong>叶节点包含指针</strong>：非聚集索引的叶节点存储的是指向实际数据行的指针（如聚集索引键），而不是数据行本身。</li>
<li><strong>可以有多个</strong>：一个表可以有多个非聚集索引，每个非聚集索引加速不同列上的查询操作。</li>
</ol>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p><strong>加速查询</strong>：非聚集索引可以显著加速特定列上的查询操作，特别是那些经常出现在 WHERE 子句中的列。</p>
<p><strong>多样性</strong>：可以在多个列上创建非聚集索引，以满足不同查询需求。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p><strong>占用空间</strong>：非聚集索引需要额外的存储空间来维护索引结构。</p>
<p><strong>维护成本</strong>：在插入、更新和删除操作时，需要维护非聚集索引，可能会增加开销。</p>
</blockquote>
<h1 id="Mysql的回表查询"><a href="#Mysql的回表查询" class="headerlink" title="Mysql的回表查询"></a>Mysql的回表查询</h1><blockquote>
<p>聚集索引叶子结点会存数据，非聚集索引存的是主键值。知道这个前提后，在 MySQL 中，回表查询（也称为回表操作）是指在使用非聚集索引进行查询时，需要从索引中获取行的指针（通常是主键值），然后再根据这些指针访问实际的数据行。这种操作通常发生在查询中需要访问的列不完全包含在索引中的情况下。如果查询的列，包含在索引中，那么就是覆盖索引的概念了。</p>
<h3 id="回表查询的过程"><a href="#回表查询的过程" class="headerlink" title="回表查询的过程"></a>回表查询的过程</h3><ol>
<li><strong>使用非聚簇索引查找</strong>：首先，MySQL 使用非聚簇索引查找满足查询条件的索引项。</li>
<li><strong>获取行指针</strong>：从非聚簇索引的叶节点获取指向实际数据行的指针（例如主键值）。</li>
<li><strong>访问数据行</strong>：根据获取的指针，访问实际的数据行以获取所需的列数据。</li>
</ol>
<h3 id="回表查询的步骤"><a href="#回表查询的步骤" class="headerlink" title="回表查询的步骤"></a>回表查询的步骤</h3><ol>
<li><strong>使用索引查找</strong>：MySQL 使用idx_last_name索引查找last_name为 ‘Smith’ 的索引项。</li>
<li><strong>获取主键值</strong>：从索引项中获取对应的emp_id（因为emp_id是主键）。</li>
<li><strong>访问数据行</strong>：根据emp_id，访问实际的数据行以获取first_name和hire_date列的数据。</li>
</ol>
</blockquote>
<h1 id="Mysql的覆盖索引"><a href="#Mysql的覆盖索引" class="headerlink" title="Mysql的覆盖索引"></a>Mysql的覆盖索引</h1><blockquote>
<p>在 MySQL 中，覆盖索引（Covering Index）是指一个索引包含了查询所需的所有列，从而使查询可以完全从索引中获取数据，而不需要访问实际的数据行。这种技术可以显著提高查询性能，因为它减少了对表数据的访问次数。</p>
<p>如果我的非聚集索引，在建立的时候，有一个 name 列，而我们查询的时候，也是 select name 这样就在非聚集索引就可以查到。那就不用回表了。</p>
<h3 id="索引覆盖的好处"><a href="#索引覆盖的好处" class="headerlink" title="索引覆盖的好处"></a>索引覆盖的好处</h3><ol>
<li><strong>减少I/O操作</strong>：查询可以直接从索引中读取所需的数据，避免了访问磁盘上的数据行，从而减少了I/O操作。</li>
<li><strong>提高查询性能</strong>：由于减少了对数据行的访问，查询速度会更快。</li>
<li><strong>减少回表操作</strong>：避免了回表操作，因为所有需要的数据都在索引中。</li>
</ol>
<h3 id="示例-Demo"><a href="#示例-Demo" class="headerlink" title="示例 Demo"></a>示例 Demo</h3><p>假设有一个表employees，并且我们在last_name列上创建了一个非聚簇索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">   emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   first_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    hire_date <span class="type">DATE</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">CREATE</span> INDEX idx_last_name <span class="keyword">ON</span> employees(last_name);</span><br></pre></td></tr></table></figure>
<p>现在我们执行一个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> first_name, hire_date <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，idx_last_name索引只包含last_name列的信息，因此 MySQL 需要通过索引找到满足条件的行指针（例如主键值），然后回表访问实际的数据行以获取first_name和hire_date列的数据。</p>
<h3 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h3><p>为了避免回表操作，可以创建一个覆盖索引，包含所有需要的列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">CREATE</span> INDEX idx_last_name_full <span class="keyword">ON</span> employees(last_name, first_name, hire_date);</span><br></pre></td></tr></table></figure>
<h3 id="覆盖索引的工作原理"><a href="#覆盖索引的工作原理" class="headerlink" title="覆盖索引的工作原理"></a>覆盖索引的工作原理</h3><ol>
<li><strong>索引查找</strong>：MySQL 使用idx_last_name_full索引查找last_name为 ‘Smith’ 的索引项。</li>
<li><strong>直接获取数据</strong>：因为索引已经包含了first_name和hire_date列，MySQL 可以直接从索引中获取所有需要的数据，而不需要回表。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>覆盖索引特别适用于那些经常需要查询少量列而这些列可以包含在一个索引中的场景。</p>
<p>查询经常使用的列，需要高查询性能的读密集型应用。</p>
</blockquote>
<h1 id="Mysql前缀索引"><a href="#Mysql前缀索引" class="headerlink" title="Mysql前缀索引"></a>Mysql前缀索引</h1><blockquote>
<p>前缀索引（Prefix Index）是一种索引类型，用于对字符串类型的列（如CHAR、VARCHAR、TEXT等）进行部分索引。通过索引字符串的前一部分，而不是整个字符串，可以显著减少索引的大小，从而提高查询性能，特别是在处理大量数据时。比如一个字符串有 30 个字符，建立索引的时候，发现取前 10 个字符就可以区分出来，这样就可以减少索引大小，也就是前缀索引。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>字符串列的长度较长，且前几位字符就能区分大多数记录。</p>
<p>需要减少索引的存储空间。</p>
<h3 id="索引选择性"><a href="#索引选择性" class="headerlink" title="索引选择性"></a>索引选择性</h3><p>这里要了解一个概念，索引的选择性（Index Selectivity），是指<strong>不重复的索引值和数据表的记录总数的比值</strong>。索引的选择性越高则查询效率越高。</p>
<p>前缀索引的目的其实就是性能和空间中找到一个平衡。假设现在有几条记录。</p>
<p>vceina12312-ceince</p>
<p>vceina1demiwad</p>
<p>dwianfgein-ceicenm</p>
<p>假设我们取前 7 位来建立前缀索引，就得到如下结果：</p>
<p>vceina1</p>
<p>vceina1</p>
<p>dwianfg</p>
<p>也就是有两条记录是相同的，那么 2/3 = 0.666666 这就是选择性得到的值。</p>
<p>那假设扩展到 8 位来建立索引呢。</p>
<p>vceina12</p>
<p>vceina1d</p>
<p>dwianfge</p>
<p>用 8 位我们就可以区分出来，找到一条记录。那相比最上面的数据，我们的空间就变小了。所以前缀索引的选择性，最好要接近于正常数据的量。</p>
<p>可以通过如下公式计算：</p>
<p>全列的数为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> column_name) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>某一长度前缀的选择性</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(column_name, prefix_length)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>如果二者计算结果约等于全列选择性的时候，就是最佳结果。</p>
<h3 id="如何创建前缀索引"><a href="#如何创建前缀索引" class="headerlink" title="如何创建前缀索引"></a>如何创建前缀索引</h3><p>创建前缀索引时，需要指定要索引的前缀长度。前缀长度应根据实际数据分布和查询需求来确定，一般选择能够有效区分数据的最小长度。</p>
<p>假设有一个包含URL的表websites，其结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> websites (</span><br><span class="line">     id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">     url <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们希望对url列创建前缀索引，可以使用如下的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">CREATE</span> INDEX idx_url_prefix <span class="keyword">ON</span> websites (url(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>上述语句创建了一个前缀长度为10的索引，即只对url列的前10个字符进行索引。</p>
<h3 id="前缀索引的优缺点"><a href="#前缀索引的优缺点" class="headerlink" title="前缀索引的优缺点"></a>前缀索引的优缺点</h3><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p><strong>减少索引大小</strong>：前缀索引只索引字符串的前部分字符，显著减少了索引占用的存储空间。</p>
<p><strong>提高性能</strong>：在某些情况下，较小的索引可以提高查询性能，特别是在内存有限的情况下。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p><strong>精确性降低</strong>：前缀索引可能无法完全区分所有记录，特别是前缀部分相同的记录。在这种情况下，可能需要进行额外的行扫描来完成查询。</p>
<p><strong>适用场景有限</strong>：前缀索引主要适用于字符串列，对于其他类型的列（如整数、日期等）不适用。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>选择合适的前缀长度</strong>：前缀长度过短可能导致索引选择性差，前缀长度过长则无法充分减少索引大小。需要根据数据分布和查询需求选择合适的前缀长度。</p>
<p><strong>不适用于ORDER BY和GROUP BY</strong>：前缀索引在某些查询（如ORDER BY和GROUP BY）中可能无法使用，因为这些操作需要完整的列值。</p>
</blockquote>
<h1 id="什么情况下应不建或少建索引"><a href="#什么情况下应不建或少建索引" class="headerlink" title="什么情况下应不建或少建索引"></a>什么情况下应不建或少建索引</h1><blockquote>
<h3 id="表的数据量较小"><a href="#表的数据量较小" class="headerlink" title="表的数据量较小"></a>表的数据量较小</h3><p>对于小表，扫描整个表的速度可能比通过索引查找还要快。在这种情况下，索引带来的性能提升非常有限，甚至可能增加不必要的开销。小表一般不需要额外的索引，除非有特定的查询需要优化。</p>
<h3 id="表的写操作频繁"><a href="#表的写操作频繁" class="headerlink" title="表的写操作频繁"></a>表的写操作频繁</h3><p>每次插入、更新或删除操作时，索引也需要更新，这会增加额外的开销。如果表的写操作非常频繁，索引的维护成本可能会超过其带来的查询优化收益。对于写操作频繁的表，应谨慎添加索引，尽量减少不必要的索引。</p>
<h3 id="索引列的基数低"><a href="#索引列的基数低" class="headerlink" title="索引列的基数低"></a>索引列的基数低</h3><p>基数低的列是指列中重复值较多的列，如性别（男/女）、布尔值（是/否）等。对于这种列，索引的选择性较差，使用索引进行查询可能不会显著提高性能。</p>
<h3 id="频繁的批量数据加载"><a href="#频繁的批量数据加载" class="headerlink" title="频繁的批量数据加载"></a>频繁的批量数据加载</h3><p>在进行批量数据加载（如批量插入或更新）时，索引的维护会显著增加操作时间。如果数据加载频繁，索引的维护成本会非常高。可以考虑在批量数据加载前暂时删除索引，加载完成后再重新创建索引。</p>
<h3 id="查询模式不确定或多变"><a href="#查询模式不确定或多变" class="headerlink" title="查询模式不确定或多变"></a>查询模式不确定或多变</h3><p>如果表的查询模式不确定或经常变化，创建索引的效果可能无法持续优化查询性能，反而可能带来不必要的维护开销。在查询模式稳定前，不要急于创建索引，先观察和分析实际查询情况，再决定是否需要索引。</p>
<h3 id="索引过多导致的维护开销"><a href="#索引过多导致的维护开销" class="headerlink" title="索引过多导致的维护开销"></a>索引过多导致的维护开销</h3><p>一个表上创建过多的索引会增加插入、更新和删除操作的开销，因为每次数据修改都需要更新所有相关的索引。此外，过多的索引也会占用更多的存储空间。合理规划和管理索引数量，避免创建过多的冗余索引。</p>
<h3 id="使用不当的复合索引"><a href="#使用不当的复合索引" class="headerlink" title="使用不当的复合索引"></a>使用不当的复合索引</h3><p>复合索引是指在多个列上创建的索引。如果查询中未使用索引的前导列，索引可能不会被使用，从而无法发挥其优化作用。在创建复合索引时，确保查询中会使用到索引的前导列，否则应重新考虑索引的设计。</p>
</blockquote>
<h1 id="Mysql常见索引失效的情况"><a href="#Mysql常见索引失效的情况" class="headerlink" title="Mysql常见索引失效的情况"></a>Mysql常见索引失效的情况</h1><blockquote>
<h3 id="使用函数或表达式"><a href="#使用函数或表达式" class="headerlink" title="使用函数或表达式"></a>使用函数或表达式</h3><p>在索引列上使用函数或表达式（如UPPER(column)、column + 1）会导致索引失效。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>当查询条件中的数据类型与索引列的数据类型不匹配时，MySQL 可能会进行隐式类型转换，从而导致索引失效。</p>
<h3 id="使用OR条件"><a href="#使用OR条件" class="headerlink" title="使用OR条件"></a>使用OR条件</h3><p>如果OR条件中的列没有索引或无法同时使用索引，也会导致索引失效。</p>
<h3 id="前导模糊查询："><a href="#前导模糊查询：" class="headerlink" title="前导模糊查询："></a>前导模糊查询：</h3><p>在 LIKE 查询中，如果模式以通配符（如%）开头，索引将失效。</p>
<h3 id="不等于操作"><a href="#不等于操作" class="headerlink" title="不等于操作"></a>不等于操作</h3><p>使用不等于操作符（如!=或&lt;&gt;）通常会导致索引失效。</p>
<h3 id="范围条件后再使用等值条件"><a href="#范围条件后再使用等值条件" class="headerlink" title="范围条件后再使用等值条件"></a>范围条件后再使用等值条件</h3><p>复合索引中，如果使用了范围条件（如&lt;、&gt;、BETWEEN），后面的等值条件可能无法使用索引。</p>
<h3 id="不满足最左前缀原则"><a href="#不满足最左前缀原则" class="headerlink" title="不满足最左前缀原则"></a>不满足最左前缀原则</h3><p>对于复合索引，查询条件必须满足最左前缀原则，否则索引将失效。</p>
<h3 id="查询条件中包含负向查询"><a href="#查询条件中包含负向查询" class="headerlink" title="查询条件中包含负向查询"></a>查询条件中包含负向查询</h3><p>例如NOT IN、NOT LIKE等负向查询条件会导致索引失效。</p>
<h3 id="数据分布不均匀"><a href="#数据分布不均匀" class="headerlink" title="数据分布不均匀"></a>数据分布不均匀</h3><p>即使有索引，如果数据分布非常不均匀，MySQL 优化器可能会选择全表扫描而不是使用索引。</p>
</blockquote>
<h1 id="唯一索引比普通索引快吗"><a href="#唯一索引比普通索引快吗" class="headerlink" title="唯一索引比普通索引快吗"></a>唯一索引比普通索引快吗</h1><blockquote>
<p>在数据库中，唯一索引和普通索引在性能上的差异主要体现在插入和更新操作上，而不是查询操作上。</p>
<h3 id="唯一索引与普通索引的区别"><a href="#唯一索引与普通索引的区别" class="headerlink" title="唯一索引与普通索引的区别"></a>唯一索引与普通索引的区别</h3><p><strong>唯一索引（Unique Index）</strong>：保证索引列中的值是唯一的，即不允许重复值。数据库系统在插入或更新数据时，会检查索引列的值是否已经存在，如果存在则会拒绝该操作。</p>
<p><strong>普通索引（Non-Unique Index）</strong>：不强制索引列中的值唯一，可以有重复值。插入和更新操作不需要进行唯一性检查。</p>
<h3 id="查询性能"><a href="#查询性能" class="headerlink" title="查询性能"></a>查询性能</h3><p>对于查询操作，唯一索引和普通索引的性能通常是相似的，因为查询操作主要依赖于索引结构（如 B+ 树或哈希表）来快速定位数据。无论是唯一索引还是普通索引，查询操作的复杂度和效率主要取决于索引的深度和数据分布情况。</p>
<h3 id="插入和更新性能"><a href="#插入和更新性能" class="headerlink" title="插入和更新性能"></a>插入和更新性能</h3><p><strong>唯一索引</strong>：需要进行唯一性检查，以确保新插入或更新的数据不会违反唯一性约束。这意味着每次插入或更新操作都需要额外的步骤来检查索引列中的值是否已经存在，这会增加一定的开销。</p>
<p><strong>普通索引</strong>：不需要进行唯一性检查，只需插入或更新索引数据即可。由于没有额外的唯一性检查步骤，插入和更新操作通常会比唯一索引更快。</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除操作对唯一索引和普通索引的性能影响较小，因为删除操作通常只涉及到从索引中移除数据，而不需要进行额外的检查。</p>
</blockquote>
<h1 id="A-B-C三个字段组成联合索引，AB-AC-BC三种情况下查询是否能命中索引？"><a href="#A-B-C三个字段组成联合索引，AB-AC-BC三种情况下查询是否能命中索引？" class="headerlink" title="A,B,C三个字段组成联合索引，AB,AC,BC三种情况下查询是否能命中索引？"></a>A,B,C三个字段组成联合索引，AB,AC,BC三种情况下查询是否能命中索引？</h1><blockquote>
<p>在数据库中，联合索引（也称为<strong>复合索引</strong>）是由多个列组成的单个索引。假设我们有一个包含字段 A、B 和 C 的联合索引(A, B, C)，我们来分析在不同情况下查询是否能命中索引。</p>
<h3 id="联合索引的基本原则"><a href="#联合索引的基本原则" class="headerlink" title="联合索引的基本原则"></a>联合索引的基本原则</h3><ol>
<li><strong>最左前缀原则</strong>：联合索引会按照定义的字段顺序进行排序。查询必须从联合索引的最左边开始，才能利用索引。</li>
<li><strong>连续性原则</strong>：如果跳过了联合索引中的某个字段，那么索引在跳过的字段之后就无法继续利用。</li>
</ol>
<h3 id="查询情况分析"><a href="#查询情况分析" class="headerlink" title="查询情况分析"></a>查询情况分析</h3><p>假设我们有一个联合索引(A, B, C)，我们来分析以下几种查询情况是否能命中索引：</p>
<h4 id="1-查询条件为-A-B"><a href="#1-查询条件为-A-B" class="headerlink" title="1. 查询条件为(A, B)"></a>1. 查询条件为(A, B)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> A <span class="operator">=</span> ? <span class="keyword">AND</span> B <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure>
<p><strong>能命中索引</strong>：这个查询条件从最左边开始使用联合索引的前两个字段(A, B)，因此可以利用索引。</p>
<h4 id="2-查询条件为-A-C"><a href="#2-查询条件为-A-C" class="headerlink" title="2. 查询条件为(A, C)"></a>2. 查询条件为(A, C)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> A <span class="operator">=</span> ? <span class="keyword">AND</span> C <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure>
<h4 id="3-查询条件为-B-C"><a href="#3-查询条件为-B-C" class="headerlink" title="3. 查询条件为(B, C)"></a>3. 查询条件为(B, C)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> B <span class="operator">=</span> ? <span class="keyword">AND</span> C <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure>
<p><strong>不能命中索引</strong>：查询条件没有从联合索引的最左边字段A开始，因此不能利用联合索引(A, B, C)。</p>
<h3 id="其他查询情况"><a href="#其他查询情况" class="headerlink" title="其他查询情况"></a>其他查询情况</h3><h4 id="4-查询条件为-A"><a href="#4-查询条件为-A" class="headerlink" title="4. 查询条件为(A)"></a>4. 查询条件为(A)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> A <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure>
<p><strong>能命中索引</strong>：查询条件只包含了联合索引的第一个字段A，可以完全利用索引。</p>
<h4 id="5-查询条件为-B"><a href="#5-查询条件为-B" class="headerlink" title="5. 查询条件为(B)"></a>5. 查询条件为(B)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> B <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure>
<p><strong>不能命中索引</strong>：查询条件没有包含联合索引的最左边字段A，因此不能利用联合索引(A, B, C)。</p>
<h4 id="6-查询条件为-A-B-C"><a href="#6-查询条件为-A-B-C" class="headerlink" title="6. 查询条件为(A, B, C)"></a>6. 查询条件为(A, B, C)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> A <span class="operator">=</span> ? <span class="keyword">AND</span> B <span class="operator">=</span> ? <span class="keyword">AND</span> C <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure>
<p><strong>能命中索引</strong>：查询条件包含了联合索引的所有字段(A, B, C)，可以完全利用索引。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">查询条件</th>
<th style="text-align:center">是否命中索引</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(A, B)</td>
<td style="text-align:center">是</td>
<td style="text-align:center">完全匹配联合索引的前缀部分。</td>
</tr>
<tr>
<td style="text-align:center">(A)</td>
<td style="text-align:center">是</td>
<td style="text-align:center">只使用了联合索引的第一列，可以命中。</td>
</tr>
<tr>
<td style="text-align:center">(A, B, C)</td>
<td style="text-align:center">是</td>
<td style="text-align:center">完全匹配整个联合索引。</td>
</tr>
<tr>
<td style="text-align:center">(A, C)</td>
<td style="text-align:center">部分</td>
<td style="text-align:center">能够利用索引中A的部分，但C不在B之后直接出现，因此只能部分利用索引。</td>
</tr>
<tr>
<td style="text-align:center">(B, C)</td>
<td style="text-align:center">否</td>
<td style="text-align:center">没有从最左边开始连续匹配索引定义，故无法利用索引。</td>
</tr>
<tr>
<td style="text-align:center">(B)</td>
<td style="text-align:center">否</td>
<td style="text-align:center">未包含联合索引中最左侧的列A，所以不能利用索引。</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<h1 id="B-树索引和哈希索引的区别"><a href="#B-树索引和哈希索引的区别" class="headerlink" title="B+树索引和哈希索引的区别"></a>B+树索引和哈希索引的区别</h1><blockquote>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树是一种<strong>平衡树</strong>数据结构，所有数据都存储在叶节点上，叶节点通过指针相连形成一个链表。内部节点只存储键值和子节点指针。</p>
<p>在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。</p>
<p>B+树的高度较低，通常为2到4层，因此查找操作的时间复杂度为 O(log n)。</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p><strong>有序性</strong>：B+树索引中的数据是有序的，适合范围查询（如BETWEEN、&lt;、&gt;等）。</p>
<p><strong>节点分裂和合并</strong>：在插入和删除数据时，B+树会保持平衡，通过节点的分裂和合并来维持树的高度。</p>
<p><strong>磁盘友好</strong>：B+树节点的大小通常与磁盘页大小匹配，减少磁盘 I/O 操作次数。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引基于<strong>哈希表</strong>实现，通过哈希函数将键值映射到哈希表中的位置。哈希表中的每个位置存储一个指向数据记录的指针。</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p><strong>无序性</strong>：哈希索引中的数据是无序的，不适合范围查询。</p>
<p><strong>高效等值查询</strong>：哈希索引对于等值查询（如=、IN）非常高效，查找时间复杂度为 O(1)。</p>
<p><strong>冲突处理</strong>：可能会发生哈希冲突，需要通过链表或其他方法来解决冲突。</p>
<p><strong>内存友好</strong>：通常哈希索引会将哈希表存储在内存中，以提高访问速度。</p>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>适合等值查询非常频繁的场景。</p>
<p>不适合需要范围查询或排序的场景。</p>
<p>适合单字段查询，不适合多字段组合查询。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>B+树索引</th>
<th>哈希索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构</td>
<td>基于平衡树结构，数据有序。</td>
<td>基于哈希表结构，数据无序。</td>
</tr>
<tr>
<td>查询性能</td>
<td>支持等值查询和范围查询；查找时间复杂度为 O(log n)。</td>
<td>等值查询性能高；查找时间复杂度为 O(1)，不支持范围查询。</td>
</tr>
<tr>
<td>适用场景</td>
<td>适合范围查询、排序操作以及多字段组合查询。</td>
<td>适合高频等值查询；不适合范围查询及排序操作。</td>
</tr>
<tr>
<td>维护成本</td>
<td>插入和删除时需维护树的平衡状态，可能涉及节点分裂或合并。</td>
<td>插入和删除相对简单，但需处理哈希冲突问题。</td>
</tr>
<tr>
<td>存储方式</td>
<td>通常存储在磁盘上，且节点大小设计以匹配磁盘页大小。</td>
<td>一般位于内存中，以此来加速数据访问过程。</td>
</tr>
</tbody>
</table>
</div>
<p>如果应用场景中需要频繁的范围查询、排序操作或多字段组合查询，选择 B+树索引。</p>
<p>如果应用场景中等值查询非常频繁且不需要范围查询或排序操作，选择哈希索引。</p>
</blockquote>
<h1 id="为什么说B-比B树更适合实际应用中作为数据库索引？"><a href="#为什么说B-比B树更适合实际应用中作为数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中作为数据库索引？"></a>为什么说B+比B树更适合实际应用中作为数据库索引？</h1><blockquote>
<h3 id="范围查询效率更高"><a href="#范围查询效率更高" class="headerlink" title="范围查询效率更高"></a>范围查询效率更高</h3><p>B树的数据存储在内节点和叶节点中，范围查询需要遍历多个节点，效率较低。B+树所有数据都存储在叶节点中，叶节点通过链表相连，形成一个有序的链表。这种结构使得范围查询和顺序访问非常高效，只需遍历叶节点链表即可完成范围查询。</p>
<h3 id="内存和磁盘I-O效率更高"><a href="#内存和磁盘I-O效率更高" class="headerlink" title="内存和磁盘I/O效率更高"></a>内存和磁盘I/O效率更高</h3><p>B树数据存储在所有节点中，内存使用较为分散，内节点和叶节点都存储数据，导致更多的磁盘I/O操作。</p>
<p>B+树内节点只存储索引键和指针，数据集中存储在叶节点中。这种结构使得内节点更小，可以在内存中存储更多的内节点，减少磁盘I/O操作，提高查询效率。</p>
<h3 id="树的高度更低、更均匀"><a href="#树的高度更低、更均匀" class="headerlink" title="树的高度更低、更均匀"></a>树的高度更低、更均匀</h3><p>B树叶节点不一定在同一层，可能会导致树的高度不均匀，增加查询的复杂度。B+树所有叶节点都在同一层，树的高度更加均匀。更低、更均匀的树高意味着更少的磁盘I/O操作，查询效率更高。</p>
<h3 id="更适合数据库的插入和删除操作"><a href="#更适合数据库的插入和删除操作" class="headerlink" title="更适合数据库的插入和删除操作"></a>更适合数据库的插入和删除操作</h3><p>B树插入和删除操作可能会导致内节点和叶节点的分裂和合并，影响树的平衡性。</p>
<p>B+树插入和删除操作主要影响叶节点，内节点的结构相对稳定。叶节点通过链表相连，插入和删除操作在叶节点上进行，不会影响内节点的平衡性。</p>
<h3 id="更高的空间利用率"><a href="#更高的空间利用率" class="headerlink" title="更高的空间利用率"></a>更高的空间利用率</h3><p>B树：由于数据存储在所有节点中，内节点和叶节点的空间利用率较低。B+树：内节点只存储索引键和指针，空间利用率更高。叶节点通过链表相连，可以更高效地利用磁盘空间。</p>
</blockquote>
<h1 id="Mysql分库分表"><a href="#Mysql分库分表" class="headerlink" title="Mysql分库分表"></a>Mysql分库分表</h1><blockquote>
<h3 id="垂直分表（Vertical-Sharding）"><a href="#垂直分表（Vertical-Sharding）" class="headerlink" title="垂直分表（Vertical Sharding）"></a>垂直分表（Vertical Sharding）</h3><p>将一个大的表按照列拆分成多个较小的表，每个表只包含部分列。根据业务关系，将不同业务字段的数据分散到不同的表中。例如，用户信息和订单信息可以拆分为用户表和订单表，每个表都只包含其相应的字段。</p>
<p>垂直拆分后业务清晰，数据维护简单。减少了I/O、锁争用和查询的字段数，提高了查询性能。</p>
<p>不过如果单表的数据量、读写压力大，垂直分表可能无法解决问题。部分业务可能无法直接通过 SQL 关联查询，增加了开发复杂度。</p>
<p>举一个例子，原有的一张用户表，user 表，里面有 ID，name，sex，drive_lincense。</p>
<p>像这种情况如果要做到垂直分表，就拆成，user 表和 user_ext 表。drive_lincense 这种信息输入附属的不重要的信息，就可以放在user_ext 内。</p>
<h3 id="水平分表（Horizontal-Sharding）"><a href="#水平分表（Horizontal-Sharding）" class="headerlink" title="水平分表（Horizontal Sharding）"></a>水平分表（Horizontal Sharding）</h3><p>将一个大的表按照某个字段的取值范围或哈希值拆分成多个较小的表，每个表存储部分数据。根据业务需求和数据量的分布情况选择合适的字段进行分片。例如，订单表可以按照订单创建时间或订单ID的哈希值拆分为多个表。</p>
<p>这种方式解决了单一表数据量过大的问题，提高了系统性能和可扩展性。但是增加了跨表查询的复杂性。需要考虑数据路由和跨库查询优化。</p>
<h3 id="分库分表联合使用"><a href="#分库分表联合使用" class="headerlink" title="分库分表联合使用"></a>分库分表联合使用</h3><p>同时进行分库和分表操作，将数据分散到多个数据库和表中。根据业务需求，将数据拆分为多个数据库。在每个数据库中，再根据业务或数据量情况进行水平或垂直分表。</p>
<h3 id="实现注意事项"><a href="#实现注意事项" class="headerlink" title="实现注意事项"></a>实现注意事项</h3><p><strong>数据分片策略</strong>：选择合适的分片策略对数据库进行分库分表操作，例如按照用户ID、订单创建时间等字段进行分片。</p>
<p><strong>数据访问路由</strong>：通过中间件（如 MyCAT、ShardingSphere、Cobar 等）来实现数据访问的路由和分片规则的管理。</p>
<p><strong>跨库查询优化</strong>：优化跨库查询，减少跨库查询的次数和复杂度，提高查询效率。</p>
</blockquote>
<h1 id="mysql主从同步原理"><a href="#mysql主从同步原理" class="headerlink" title="mysql主从同步原理"></a>mysql主从同步原理</h1><blockquote>
<p>MySQL 主从同步（Replication）是一种将数据从一个 MySQL 数据库服务器（称为主服务器）复制到一个或多个 MySQL 数据库服务器（称为从服务器）的过程。这种机制通常用于提高数据冗余、负载均衡和数据备份。</p>
<p>主从同步的核心原理是将主服务器上的二进制日志复制到从服务器，并在从服务器上执行这些日志中的操作。相对于传输大量的SQL语句，只传输二进制日志可以节省网络带宽，提高同步性能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/54e1373e/image-20250430162226942.png" alt="image-20250430162226942"></p>
<h3 id="主服务器（Master）"><a href="#主服务器（Master）" class="headerlink" title="主服务器（Master）"></a>主服务器（Master）</h3><p>主服务器负责处理写入操作（INSERT、UPDATE、DELETE 等）并记录这些操作的日志（称为二进制日志，Binary Log）。</p>
<h3 id="二进制日志（Binary-Log）"><a href="#二进制日志（Binary-Log）" class="headerlink" title="二进制日志（Binary Log）"></a>二进制日志（Binary Log）</h3><p>在主服务器上，每次数据更改操作都会被记录到二进制日志文件中。二进制日志包含了所有对数据库进行的更改操作的详细记录。</p>
<h3 id="从服务器（Slave）"><a href="#从服务器（Slave）" class="headerlink" title="从服务器（Slave）"></a>从服务器（Slave）</h3><p>从服务器连接到主服务器，并从主服务器获取二进制日志。它会将这些日志应用到自己的数据库中，以保持与主服务器的数据一致。</p>
<h3 id="中继日志（Relay-Log）"><a href="#中继日志（Relay-Log）" class="headerlink" title="中继日志（Relay Log）"></a>中继日志（Relay Log）</h3><p>从服务器将从主服务器获取的二进制日志写入到中继日志文件中，然后再从中继日志中读取并应用这些更改。</p>
<h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><h4 id="1、-主服务器记录更改到二进制日志"><a href="#1、-主服务器记录更改到二进制日志" class="headerlink" title="1、 主服务器记录更改到二进制日志"></a>1、 主服务器记录更改到二进制日志</h4><p>当主服务器上的数据发生更改时，这些更改会被记录到二进制日志文件中。</p>
<h4 id="2、从服务器读取二进制日志"><a href="#2、从服务器读取二进制日志" class="headerlink" title="2、从服务器读取二进制日志"></a>2、从服务器读取二进制日志</h4><p>从服务器上的 I/O 线程负责连接到主服务器并读取二进制日志，将其写入到从服务器上的中继日志文件中。中继日志可以作为主服务器的副本。</p>
<h4 id="3、从服务器应用中继日志"><a href="#3、从服务器应用中继日志" class="headerlink" title="3、从服务器应用中继日志"></a>3、从服务器应用中继日志</h4><p>从服务器上的 SQL 线程读取中继日志文件，并将其中的更改应用到从服务器的数据库中。这样就和主服务器保持了一致。在这个过程中，会生成一个称为复制事件（Replication Event）的记录，并将其更新到主服务器上的复制信息表中。这个复制事件包含了从服务器接收和应用二进制日志事件的相关信息。</p>
<h4 id="4、心跳检查"><a href="#4、心跳检查" class="headerlink" title="4、心跳检查"></a>4、心跳检查</h4><p>主服务器和从服务器之间会定期进行心跳检查，以确保连接的正常和可靠性。如果从服务器在一定时间内没有收到来自主服务器的二进制日志事件，或者发生连接错误，它将尝试重新连接主服务器并继续复制过程。</p>
<h3 id="复制如何配置"><a href="#复制如何配置" class="headerlink" title="复制如何配置"></a>复制如何配置</h3><h4 id="配置主服务器"><a href="#配置主服务器" class="headerlink" title="配置主服务器"></a>配置主服务器</h4><p>启用二进制日志记录（在my.cnf文件中设置log_bin），设置服务器唯一 ID（在my.cnf文件中设置server-id）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/54e1373e/image-20250430162246060.png" alt="image-20250430162246060"></p>
<h4 id="配置从服务器"><a href="#配置从服务器" class="headerlink" title="配置从服务器"></a>配置从服务器</h4><p>设置服务器唯一 ID（在my.cnf文件中设置server-id）。</p>
<p>配置从服务器连接到主服务器（使用CHANGE MASTER TO语句）。</p>
<p>启动从服务器的复制线程（使用START SLAVE语句）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/54e1373e/image-20250430162308364.png" alt="image-20250430162308364"></p>
</blockquote>
<h1 id="mysql主从同步延迟的原因和解决办法"><a href="#mysql主从同步延迟的原因和解决办法" class="headerlink" title="mysql主从同步延迟的原因和解决办法"></a>mysql主从同步延迟的原因和解决办法</h1><blockquote>
<p>MySQL 主从同步延迟（Replication Lag）是指从服务器与主服务器之间的数据复制存在时间差，导致从服务器上的数据不够新鲜。这种延迟可能会影响应用程序的性能和数据一致性。</p>
<h3 id="延迟原因"><a href="#延迟原因" class="headerlink" title="延迟原因"></a>延迟原因</h3><p><strong>主服务器负载过高</strong>：主服务器的高负载会影响二进制日志的生成和发送速度，从而导致从服务器的延迟。</p>
<p><strong>从服务器性能瓶颈</strong>：从服务器的硬件资源（如 CPU、内存、磁盘 I/O）不足，导致处理中继日志的速度慢。</p>
<p><strong>网络延迟</strong>：主从服务器之间的网络延迟或带宽不足，会影响二进制日志的传输速度。</p>
<p><strong>大事务</strong>：大事务（如批量插入或更新）会生成大量的二进制日志，从而增加从服务器的处理时间。</p>
<p><strong>从服务器上的锁争用</strong>：从服务器在应用中继日志时，可能会遇到锁争用问题，导致延迟。</p>
<p><strong>配置不当</strong>：MySQL 配置不当（如缓冲区大小、线程数等）会影响复制性能。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>优化主服务器性能</strong>：减轻主服务器的负载，减少不必要的查询。可以使用缓存来减少数据库查询次数。</p>
<p><strong>提升从服务器性能</strong>：升级从服务器的硬件资源，如增加 CPU 核心数、内存容量和磁盘 I/O 性能，确保从服务器的配置（如innodb_buffer_pool_size、innodb_log_file_size）适合其硬件资源。</p>
<p><strong>优化网络性能</strong>：确保主从服务器之间的网络连接稳定且带宽充足。使用低延迟、高带宽的网络连接。</p>
<p><strong>拆分大事务</strong>：将大事务拆分为多个小事务，以减少单个事务的处理时间。</p>
<p><strong>调整复制配置</strong>：增加从服务器上的 I/O 线程和 SQL 线程数量（适用于 MySQL 8.0 及更高版本），调整slave_parallel_workers参数以启用并行复制。</p>
<p><strong>监控和调整锁争用</strong>：使用监控工具（如SHOW PROCESSLIST、SHOW ENGINE INNODB STATUS）监控锁争用情况，并优化应用程序的锁使用策略。</p>
<p><strong>使用半同步复制</strong>：启用半同步复制（Semi-Synchronous Replication），确保主服务器在提交事务后等待至少一个从服务器确认已收到二进制日志，从而减少延迟。</p>
</blockquote>
<h1 id="mysql的全复制、半复制、异步复制"><a href="#mysql的全复制、半复制、异步复制" class="headerlink" title="mysql的全复制、半复制、异步复制"></a>mysql的全复制、半复制、异步复制</h1><blockquote>
<h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>MySQL 默认使用异步复制。主服务器（Master）在提交事务后，不需要等待从服务器（Slave）的确认，事务即被认为完成。由于主服务器不需要等待从服务器的响应，性能较好。存在复制延迟的可能性，因为从服务器可能会滞后于主服务器。这种方式可以理解为主提交完之后，不确保是否从都收到了，直接成功。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>主服务器将事务写入二进制日志（binlog）。从服务器读取主服务器的二进制日志，并将其应用到自己的数据副本中。注意：一会对比看到其他的方式，你会发现本方式不需要任何回应。主要适用于对数据一致性要求不高，但对性能要求较高的场景或者读操作较多的应用，通过读写分离提高性能。</p>
<h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>在主服务器提交事务时，至少需要等待一个从服务器确认已经接收到并写入中继日志（relay log）后，事务才被认为完成。相对于异步复制，性能稍有下降，因为主服务器需要等待从服务器的确认。减少了数据丢失的风险，但仍然存在一定的复制延迟。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/54e1373e/image-20250430162737239.png" alt="image-20250430162737239"></p>
<h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>主服务器将事务写入二进制日志。主服务器等待至少一个从服务器确认已接收到该事务并写入中继日志。收到确认后，主服务器才向客户端确认事务提交成功。适用于需要较高的数据一致性，但仍希望有较好的性能。</p>
<h3 id="全同步复制"><a href="#全同步复制" class="headerlink" title="全同步复制"></a>全同步复制</h3><p>在主服务器提交事务时，必须等待所有从服务器确认已经接收到并应用了该事务后，事务才被认为完成。性能较差，因为主服务器需要等待所有从服务器的确认。延迟较高，但保证了数据的一致性和可靠性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/54e1373e/image-20250430162815118.png" alt="image-20250430162815118"></p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>主服务器将事务写入二进制日志。主服务器等待所有从服务器确认已接收到并应用了该事务。收到所有确认后，主服务器才向客户端确认事务提交成功。</p>
<h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><p>对数据一致性要求极高且可以容忍较高延迟的场景。适用于极端关键的数据系统，如某些金融系统、军事系统等。</p>
</blockquote>
<h1 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h1><blockquote>
<h3 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h3><p>DROP用于删除数据库对象，如表、视图、索引等。可以删除表、数据库、视图、索引等。</p>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>完全删除表及其所有数据。删除表后，表的结构和数据都将永久消失，且无法恢复（除非有备份）。不会触发DELETE触发器。无法回滚（不可逆操作）。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE用于删除表中符合条件的行。只能删除表中的数据行。</p>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><p>可以通过WHERE子句指定删除哪些行，如果没有WHERE子句，将删除表中所有行，但表结构和索引保留。删除操作会记录在事务日志中，因此可以回滚（可逆操作）。可以触发DELETE触发器。相对较慢，因为每行删除操作都会记录在日志中，并且需要考虑事务处理。</p>
<h3 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h3><p>TRUNCATE用于快速删除表中的所有行。直接操作表中的所有数据行。</p>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p>删除所有行，但保留表结构及其列、索引等元数据。比DELETE快，因为它不逐行删除数据，而是直接释放数据页。无法回滚（不可逆操作），但在某些数据库系统中，TRUNCATE可能被视为DDL操作，具体行为取决于数据库系统的实现。重置自增列（AUTO_INCREMENT）计数器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作对象</th>
<th style="text-align:center">是否可回滚</th>
<th style="text-align:center">性能</th>
<th style="text-align:center">触发器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DROP</td>
<td style="text-align:center">不可回滚</td>
<td style="text-align:center">通常比DELETE快，因为它不逐行处理数据。</td>
<td style="text-align:center">不会触发DELETE触发器</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">可回滚</td>
<td style="text-align:center">较慢，特别是当删除大量数据时，因为每行操作都会被记录在日志中。</td>
<td style="text-align:center">会触发DELETE触发器</td>
</tr>
<tr>
<td style="text-align:center">TRUNCATE</td>
<td style="text-align:center">通常不可回滚（视数据库实现而定）</td>
<td style="text-align:center">通常比DELETE快，因为它不逐行处理数据。</td>
<td style="text-align:center">不会触发DELETE触发器</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<h1 id="多版本并发控制MVCC"><a href="#多版本并发控制MVCC" class="headerlink" title="多版本并发控制MVCC"></a>多版本并发控制MVCC</h1><blockquote>
<p>MVCC是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照（隔离级别RC下），所以MVCC为数据库解决了以下问题：</p>
<p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。</p>
<p>解决脏读、幻读、不可重复读等事务隔离问题，但是不能解决更新丢失问题。</p>
<h3 id="MVCC-的工作原理"><a href="#MVCC-的工作原理" class="headerlink" title="MVCC 的工作原理"></a>MVCC 的工作原理</h3><p>MVCC 通过在数据库中存储每个数据行的多个版本来实现并发控制。每个事务在读取数据时，可以看到一个一致性快照，而不会被其他事务的并发修改所干扰。这种机制主要依赖于以下几个核心概念：</p>
<p><strong>版本控制</strong>：每个数据行都有多个版本，每个版本与一个特定的事务相关联。每次数据行被修改时，都会创建一个新版本，而旧版本则被保留。</p>
<p><strong>事务快照</strong>：每个事务在开始时都会获取一个一致性快照，这个快照包含了事务开始时数据库的状态。事务在执行期间，只能看到属于这个快照的数据版本，而不会看到其他事务提交的修改。</p>
<p><strong>事务ID</strong>：每个事务都有一个唯一的事务ID，用于标识事务的开始和结束时间。事务ID 用于确定哪些数据版本对当前事务可见。</p>
<p><strong>可见性规则</strong>：数据库系统使用事务ID 和版本号来决定哪些数据版本对当前事务可见。通常，事务只能看到在其开始之前已经提交的版本，而看不到在其开始之后创建的版本。</p>
<h3 id="MVCC-的优势"><a href="#MVCC-的优势" class="headerlink" title="MVCC 的优势"></a>MVCC 的优势</h3><p><strong>提高并发性</strong>：MVCC 允许多个事务同时读取和写入数据，而不会相互阻塞。这大大提高了数据库的并发性和性能。</p>
<p><strong>减少锁争用</strong>：由于每个事务在读取数据时不需要加锁，MVCC 减少了锁争用和死锁的可能性。</p>
<p><strong>一致性视图</strong>：每个事务在开始时获取一致性快照，确保在整个事务期间看到的数据是一致的。</p>
<h3 id="MVCC-的实现细节"><a href="#MVCC-的实现细节" class="headerlink" title="MVCC 的实现细节"></a>MVCC 的实现细节</h3><p>不同的数据库系统对 MVCC 的实现细节有所不同，但通常包括以下几个方面：</p>
<p><strong>版本链</strong>：每个数据行维护一个版本链，链中的每个节点表示一个版本。每个版本包含数据行的值、创建该版本的事务ID 和删除该版本的事务ID（如果适用）。</p>
<p><strong>垃圾回收</strong>：随着时间的推移，旧的版本会变得不再需要。数据库系统需要定期进行垃圾回收，删除不再需要的旧版本，以释放存储空间。</p>
<p><strong>快照隔离</strong>：MVCC 通常与快照隔离级别结合使用，确保事务在执行期间看到一致的快照。快照隔离级别是介于可重复读和串行化之间的一种隔离级别。</p>
</blockquote>
<h1 id="MVCC作用"><a href="#MVCC作用" class="headerlink" title="MVCC作用"></a>MVCC作用</h1><blockquote>
<h3 id="提高并发性"><a href="#提高并发性" class="headerlink" title="提高并发性"></a>提高并发性</h3><p>MVCC 允许多个事务同时执行读写操作，而无需互相阻塞或等待。这极大地提高了数据库的并发处理能力，特别是在高并发环境中。</p>
<h3 id="减少锁争用"><a href="#减少锁争用" class="headerlink" title="减少锁争用"></a>减少锁争用</h3><p>在传统的锁机制中，读写操作需要加锁，容易导致锁争用和死锁问题。MVCC 通过版本控制，使得读取操作不需要加锁，从而减少了锁争用的频率。</p>
<h3 id="提供一致性视图"><a href="#提供一致性视图" class="headerlink" title="提供一致性视图"></a>提供一致性视图</h3><p>MVCC 为每个事务提供一个一致性的快照视图，使得事务在执行过程中看到的数据是固定的，不会受到其他并发事务的影响。这简化了应用程序的开发，因为开发者无需担心数据在事务执行过程中发生变化。</p>
<h3 id="避免读写冲突"><a href="#避免读写冲突" class="headerlink" title="避免读写冲突"></a>避免读写冲突</h3><p>在 MVCC 中，读操作不会阻塞写操作，写操作也不会阻塞读操作。这避免了读写冲突，提高了系统的整体性能和响应速度。</p>
<h3 id="减少死锁"><a href="#减少死锁" class="headerlink" title="减少死锁"></a>减少死锁</h3><p>由于读操作不需要加锁，MVCC 减少了死锁的可能性。死锁通常发生在多个事务互相等待资源释放的情况下，而 MVCC 的无锁读操作减少了这种情况发生的机会。</p>
<h3 id="提高读性能"><a href="#提高读性能" class="headerlink" title="提高读性能"></a>提高读性能</h3><p>MVCC 提供了无锁的读操作，读操作直接读取数据的快照版本，不需要等待其他事务完成。这极大地提高了读操作的性能，尤其是在读操作频繁的场景下。</p>
<h3 id="实现更高的隔离级别"><a href="#实现更高的隔离级别" class="headerlink" title="实现更高的隔离级别"></a>实现更高的隔离级别</h3><p>MVCC 支持实现更高的隔离级别，如快照隔离（Snapshot Isolation），在这种隔离级别下，事务可以看到一个一致的快照视图，同时避免了脏读和不可重复读等问题。</p>
<p>假设有一个银行账户表accounts：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| id | balance|</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 1000   |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>
<h4 id="场景-1：高并发读写"><a href="#场景-1：高并发读写" class="headerlink" title="场景 1：高并发读写"></a>场景 1：高并发读写</h4><ul>
<li>事务 A：读取账户余额</li>
<li>事务 B：更新账户余额</li>
</ul>
<p>在传统的锁机制下，事务 A 和事务 B 可能会互相阻塞。然而在 MVCC 中：</p>
<ol>
<li>事务 A 开始，读取balance = 1000。</li>
<li>事务 B 开始，更新balance为 1200。</li>
<li>事务 A 继续读取，仍然看到balance = 1000。</li>
<li>事务 B 提交后，新的事务可以看到balance = 1200。</li>
</ol>
<p>这种情况下，事务 A 和事务 B 可以并发执行，互不影响。</p>
<h4 id="场景-2：避免读写冲突"><a href="#场景-2：避免读写冲突" class="headerlink" title="场景 2：避免读写冲突"></a>场景 2：避免读写冲突</h4><ul>
<li>事务 C：读取账户余额</li>
<li>事务 D：更新账户余额</li>
</ul>
<p>在 MVCC 中：</p>
<ol>
<li>事务 C 开始，读取balance = 1000。</li>
<li>事务 D 开始，更新balance为 1500。</li>
<li>事务 D 提交后，新的事务可以看到balance = 1500。</li>
<li>事务 C 继续读取，仍然看到balance = 1000。</li>
</ol>
<p>通过 MVCC，读取操作和写入操作可以并发执行，避免了读写冲突。</p>
</blockquote>
<h1 id="MySQL中有哪几种锁"><a href="#MySQL中有哪几种锁" class="headerlink" title="MySQL中有哪几种锁"></a>MySQL中有哪几种锁</h1><blockquote>
<h3 id="表级锁（Table-Locks）"><a href="#表级锁（Table-Locks）" class="headerlink" title="表级锁（Table Locks）"></a>表级锁（Table Locks）</h3><p><strong>表锁（Table Lock）</strong>：表级锁是对整个表进行加锁。它有两种类型：</p>
<ul>
<li><strong>读锁（Read Lock）</strong>：多个事务可以同时对表加读锁，但不能对表进行写操作。</li>
<li><strong>写锁（Write Lock）</strong>：当一个事务对表加写锁时，其他事务不能对该表进行读或写操作。</li>
</ul>
<p>表锁的优点是实现简单，开销较小，但在高并发情况下可能会导致较多的锁等待和性能瓶颈。</p>
<h3 id="行级锁（Row-Locks）"><a href="#行级锁（Row-Locks）" class="headerlink" title="行级锁（Row Locks）"></a>行级锁（Row Locks）</h3><p>行级锁是对单行记录进行加锁，适用于 InnoDB 存储引擎。它的粒度更细，可以提高并发性能。行级锁主要有两种类型：</p>
<p><strong>共享锁（Share Lock，S 锁）</strong>：允许事务读取一行数据，但不允许修改。其他事务也可以获得该行的共享锁。</p>
<p><strong>排他锁（Exclusive Lock，X 锁）</strong>：允许事务读取和修改一行数据，但不允许其他事务获取该行的任何锁。</p>
<h3 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h3><p>间隙锁是 InnoDB 存储引擎特有的锁，用于防止幻读现象。间隙锁不仅锁定现有的行，还锁定一个范围内的间隙，以防止其他事务在这个间隙内插入新行。</p>
<p><strong>间隙锁（Gap Lock）</strong>：锁定一个范围内的间隙，但不锁定间隙中的行。</p>
<p><strong>临键锁（Next-Key Lock）</strong>：是行锁和间隙锁的组合，锁定一个行和它前面的间隙。</p>
<h3 id="意向锁（Intention-Locks）"><a href="#意向锁（Intention-Locks）" class="headerlink" title="意向锁（Intention Locks）"></a>意向锁（Intention Locks）</h3><p>意向锁是 InnoDB 存储引擎用来支持多粒度锁定的机制，主要用于表级锁和行级锁的协调。意向锁有两种类型：</p>
<p><strong>意向共享锁（Intention Share Lock，IS 锁）</strong>：事务打算对某些行加共享锁。</p>
<p><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务打算对某些行加排他锁。</p>
<p>意向锁本身不会阻塞其他事务，但会阻止其他事务对表加相冲突的表级锁。</p>
<h3 id="自增锁（Auto-Increment-Locks）"><a href="#自增锁（Auto-Increment-Locks）" class="headerlink" title="自增锁（Auto-Increment Locks）"></a>自增锁（Auto-Increment Locks）</h3><p>自增锁用于处理自增列（AUTO_INCREMENT）的并发问题。InnoDB 存储引擎使用一种特殊的表级锁来确保自增列的值在并发插入时的正确性。</p>
<h3 id="元数据锁（Metadata-Locks）"><a href="#元数据锁（Metadata-Locks）" class="headerlink" title="元数据锁（Metadata Locks）"></a>元数据锁（Metadata Locks）</h3><p>元数据锁用于保护表结构的变化，确保在表结构变更（如ALTER TABLE）时不会有其他事务对表进行操作。主要用于 DDL（数据定义语言）操作。</p>
<h3 id="外键锁（Foreign-Key-Locks）"><a href="#外键锁（Foreign-Key-Locks）" class="headerlink" title="外键锁（Foreign Key Locks）"></a>外键锁（Foreign Key Locks）</h3><p>外键锁用于保证外键约束的完整性。InnoDB 存储引擎在插入、更新或删除涉及外键的记录时，会自动加锁以确保外键约束不被破坏。</p>
<h3 id="临时锁（Temporary-Locks）"><a href="#临时锁（Temporary-Locks）" class="headerlink" title="临时锁（Temporary Locks）"></a>临时锁（Temporary Locks）</h3><p>临时锁是 MySQL 在某些特定操作（如复制、备份等）过程中使用的锁，用于确保操作的原子性和一致性。</p>
</blockquote>
<h1 id="Mysql的常用函数"><a href="#Mysql的常用函数" class="headerlink" title="Mysql的常用函数"></a>Mysql的常用函数</h1><blockquote>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><strong>CONCAT(str1, str2, …)</strong>：连接多个字符串。</p>
<p><strong>SUBSTRING(str, pos, len)</strong>：从字符串str的pos位置开始，截取长度为len的子字符串。</p>
<p><strong>LENGTH(str)</strong>：返回字符串的长度（字节数）。</p>
<p><strong>UPPER(str)</strong>：将字符串转换为大写。</p>
<p><strong>LOWER(str)</strong>：将字符串转换为小写。</p>
<p><strong>TRIM(str)</strong>：去除字符串两端的空格。</p>
<p><strong>REPLACE(str, from_str, to_str)</strong>：将字符串str中的from_str替换为to_str。</p>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p><strong>ABS(x)</strong>：返回x的绝对值。</p>
<p><strong>CEIL(x)</strong>或<strong>CEILING(x)</strong>：返回大于或等于x的最小整数。</p>
<p><strong>FLOOR(x)</strong>：返回小于或等于x的最大整数。</p>
<p><strong>ROUND(x, d)</strong>：将x四舍五入到d位小数。</p>
<p><strong>RAND()</strong>：返回一个 0 到 1 之间的随机数。</p>
<p><strong>POWER(x, y)</strong>或<strong>POW(x, y)</strong>：返回x的y次幂。</p>
<h3 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h3><p><strong>NOW()</strong>：返回当前日期和时间。</p>
<p><strong>CURDATE()</strong>或<strong>CURRENT_DATE()</strong>：返回当前日期。</p>
<p><strong>CURTIME()</strong>或<strong>CURRENT_TIME()</strong>：返回当前时间。</p>
<p><strong>CURTIME()</strong>或<strong>CURRENT_TIME()</strong>：返回当前时间。</p>
<p><strong>DATEDIFF(date1, date2)</strong>：返回两个日期之间的天数差。</p>
<p><strong>ADDDATE(date, interval)</strong>或<strong>DATE_ADD(date, interval)</strong>：在日期上加上一个时间间隔。</p>
<p><strong>SUBDATE(date, interval)</strong>或<strong>DATE_SUB(date, interval)</strong>：在日期上减去一个时间间隔。</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><strong>COUNT(expression)</strong>：返回满足条件的行数。</p>
<p><strong>SUM(expression)</strong>：返回数值列的总和。</p>
<p><strong>AVG(expression)</strong>：返回数值列的平均值。</p>
<p><strong>MAX(expression)</strong>：返回列的最大值。</p>
<p><strong>MIN(expression)</strong>：返回列的最小值。</p>
<h3 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h3><p><strong>IF(condition, true_value, false_value)</strong>：条件判断函数。</p>
<p><strong>COALESCE(value1, value2, …)</strong>：返回第一个非 NULL 的值。</p>
<p><strong>IFNULL(expression, alt_value)</strong>：如果expression为 NULL，返回alt_value。</p>
<p><strong>NULLIF(expr1, expr2)</strong>：如果expr1等于expr2，返回 NULL，否则返回expr1。</p>
</blockquote>
<h1 id="Mysql的常用数据类型"><a href="#Mysql的常用数据类型" class="headerlink" title="Mysql的常用数据类型"></a>Mysql的常用数据类型</h1><blockquote>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p><strong>TINYINT</strong>: 1 字节，范围 -128 到 127 或 0 到 255（无符号）。</p>
<p><strong>SMALLINT</strong>: 2 字节，范围 -32,768 到 32,767 或 0 到 65,535（无符号）。</p>
<p><strong>MEDIUMINT</strong>: 3 字节，范围 -8,388,608 到 8,388,607 或 0 到 16,777,215（无符号）。</p>
<p><strong>INT</strong>: 4 字节，范围 -2,147,483,648 到 2,147,483,647 或 0 到 4,294,967,295（无符号）。</p>
<p><strong>BIGINT</strong>: 8 字节，范围 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 或 0 到 18,446,744,073,709,551,615（无符号）。</p>
<h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><p><strong>FLOAT</strong>: 单精度浮点数，4 字节。</p>
<p><strong>DOUBLE</strong>: 双精度浮点数，8 字节。</p>
<h4 id="定点数类型"><a href="#定点数类型" class="headerlink" title="定点数类型"></a>定点数类型</h4><p><strong>DECIMAL</strong>: 精确的定点数，用户可以指定精度和小数位数。适用于需要高精度的金融计算。</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>CHAR</strong>: 固定长度字符串，最多 255 个字符。</p>
<p><strong>VARCHAR</strong>: 可变长度字符串，最多 65,535 个字符（实际长度受行大小限制）。</p>
<p><strong>TINYTEXT</strong>: 最多 255 个字符。</p>
<p><strong>TEXT</strong>: 最多 65,535 个字符。</p>
<p><strong>MEDIUMTEXT</strong>: 最多 16,777,215 个字符。</p>
<p><strong>LONGTEXT</strong>: 最多 4,294,967,295 个字符。</p>
<h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><p><strong>BINARY</strong>: 固定长度二进制数据，最多 255 字节。</p>
<p><strong>VARBINARY</strong>: 可变长度二进制数据，最多 65,535 字节。</p>
<p><strong>TINYBLOB</strong>: 最多 255 字节的二进制数据。</p>
<p><strong>BLOB</strong>: 最多 65,535 字节的二进制数据。</p>
<p><strong>MEDIUMBLOB</strong>: 最多 16,777,215 字节的二进制数据。</p>
<p><strong>LONGBLOB</strong>: 最多 4,294,967,295 字节的二进制数据。</p>
<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p><strong>DATE</strong>: 日期，格式为 ‘YYYY-MM-DD’，范围 ‘1000-01-01’ 到 ‘9999-12-31’。</p>
<p><strong>TIME</strong>: 时间，格式为 ‘HH:MM:SS’，范围 ‘-838:59:59’ 到 ‘838:59:59’。</p>
<p><strong>DATETIME</strong>: 日期和时间，格式为 ‘YYYY-MM-DD HH:MM:SS’，范围 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’。</p>
<p><strong>TIMESTAMP</strong>: 时间戳，格式为 ‘YYYY-MM-DD HH:MM:SS’，范围 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC。</p>
<p><strong>YEAR</strong>: 年份，格式为 ‘YYYY’，范围 ‘1901’ 到 ‘2155’。</p>
<h3 id="JSON-类型"><a href="#JSON-类型" class="headerlink" title="JSON 类型"></a>JSON 类型</h3><p><strong>JSON</strong>: 用于存储 JSON 格式的数据，可以方便地进行 JSON 数据的存储和查询。</p>
<h3 id="枚举和集合类型"><a href="#枚举和集合类型" class="headerlink" title="枚举和集合类型"></a>枚举和集合类型</h3><p><strong>ENUM</strong>: 枚举类型，字符串对象的集合，每次只能存储一个值。</p>
<p><strong>SET</strong>: 集合类型，字符串对象的集合，每次可以存储多个值。</p>
<h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><p><strong>BOOLEAN</strong>: 布尔类型，实际上是 TINYINT(1) 的别名，0 表示 FALSE，非 0 表示 TRUE。</p>
<p><strong>SERIAL</strong>: 自动递增的整数类型，实际上是<code>BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code>的别名。</p>
</blockquote>
<h1 id="Mysql的char和varchar的区别"><a href="#Mysql的char和varchar的区别" class="headerlink" title="Mysql的char和varchar的区别"></a>Mysql的char和varchar的区别</h1><blockquote>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><strong>CHAR</strong>：CHAR是固定长度的字符串类型。无论实际存储的字符串长度是多少，CHAR类型的字段都会占用固定的空间。例如，CHAR(10)类型的字段，无论存储的字符串是 “abc” 还是 “abcdefghij”，都会占用 10 个字符的空间。如果存储的字符串长度小于定义的长度，MySQL 会在字符串的末尾填充空格以达到指定的长度。</p>
<p><strong>VARCHAR</strong>：VARCHAR是可变长度的字符串类型。VARCHAR类型的字段根据实际存储的字符串长度来分配空间。例如，VARCHAR(10)类型的字段，存储 “abc” 只占用 3 个字符的空间（加上一个额外的字节用于存储字符串的长度）。VARCHAR类型的字段在存储时会记录实际字符串的长度，因此不会有额外的空格填充。</p>
<h3 id="存储效率"><a href="#存储效率" class="headerlink" title="存储效率"></a>存储效率</h3><p><strong>CHAR</strong>：由于是固定长度，CHAR类型的字段在存储和检索时效率较高，特别适用于存储长度固定的字符串（如国家代码、邮政编码等）。但对于长度变化较大的字符串，CHAR类型可能会浪费大量的存储空间。</p>
<p><strong>VARCHAR</strong>：VARCHAR类型的字段在存储空间上更节省，因为它只分配实际需要的空间。对于长度变化较大的字符串，VARCHAR类型更加合适。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><strong>CHAR</strong>：由于固定长度，CHAR类型的字段在进行比较和检索时速度较快。适用于需要频繁查询和比较的字段。</p>
<p><strong>VARCHAR</strong>：VARCHAR类型的字段在存储和检索时需要额外的长度信息，因此在某些情况下性能可能稍逊于CHAR。适用于长度不固定且不需要频繁比较的字段。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>CHAR</strong>：适用于存储长度固定的字符串，如固定长度的编码、标识符等。例如，存储国家代码（如 “USA”、”CHN”）或邮政编码（如 “12345”）。</p>
<p><strong>VARCHAR</strong>：适用于存储长度可变的字符串，如姓名、地址、描述等。例如，存储用户的姓名、电子邮件地址或文章内容。</p>
</blockquote>
<h1 id="mysql中int-1-和int-10-的区别"><a href="#mysql中int-1-和int-10-的区别" class="headerlink" title="mysql中int(1)和int(10)的区别"></a>mysql中int(1)和int(10)的区别</h1><blockquote>
<p>INT(1)和INT(10)的区别并不在于它们能存储的数值范围，而是在于显示宽度（display width）。</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>无论是INT(1)还是INT(10)，它们的数值范围都是由INT类型决定的，而不是括号中的数字。</p>
<p>INT类型的数值范围（无符号）是-2147483648到2147483647。</p>
<h3 id="显示宽度"><a href="#显示宽度" class="headerlink" title="显示宽度"></a>显示宽度</h3><p>INT(1)和INT(10)中的数字（1 和 10）表示的是显示宽度，而不是存储的数值范围。</p>
<p>显示宽度是指当你使用ZEROFILL属性时，MySQL 会将数字填充到指定的宽度。例如，如果你定义了INT(5) ZEROFILL，并插入值42，它会显示为00042。</p>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p><strong>存储大小</strong>：显示宽度不会影响实际的存储大小。INT类型始终占用 4 个字节的存储空间。</p>
<p><strong>显示效果</strong>：显示宽度主要影响的是数据的显示效果，尤其是在使用ZEROFILL属性时。没有ZEROFILL属性时，显示宽度的影响很小。</p>
</blockquote>
<h1 id="blob和text的区别"><a href="#blob和text的区别" class="headerlink" title="blob和text的区别"></a>blob和text的区别</h1><blockquote>
<p>BLOB 和 TEXT 是两种用于存储大数据的列类型。</p>
<h3 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h3><p><strong>BLOB</strong>（Binary Large Object）：用于存储二进制数据，如图像、音频、视频等。BLOB字段中的数据以二进制格式存储，不进行字符集转换。</p>
<p><strong>TEXT</strong>：用于存储大文本数据，如长文章、日志等。TEXT字段中的数据以字符格式存储，受字符集和排序规则的影响。</p>
<h3 id="类型和大小"><a href="#类型和大小" class="headerlink" title="类型和大小"></a>类型和大小</h3><p>BLOB和TEXT都有四种不同的类型，每种类型支持不同的数据大小：</p>
<p><strong>TINYBLOB</strong>/<strong>TINYTEXT</strong>：最大长度 255 字节</p>
<p><strong>BLOB</strong>/<strong>TEXT</strong>：最大长度 65,535 字节（约 64 KB）</p>
<p><strong>MEDIUMBLOB</strong>/<strong>MEDIUMTEXT</strong>：最大长度 16,777,215 字节（约 16 MB）</p>
<p><strong>LONGBLOB</strong>/<strong>LONGTEXT</strong>：最大长度 4,294,967,295 字节（约 4 GB）</p>
<h3 id="字符集和排序规则"><a href="#字符集和排序规则" class="headerlink" title="字符集和排序规则"></a>字符集和排序规则</h3><p><strong>BLOB</strong>：不使用字符集和排序规则。数据按字节存储和比较。</p>
<p><strong>TEXT</strong>：使用字符集和排序规则。数据按字符存储和比较，字符集转换会影响数据的存储和检索。</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>BLOB</strong>：适用于存储二进制数据，如图像、音频、视频文件等。</p>
<p><strong>TEXT</strong>：适用于存储大文本数据，如文章、日志、HTML 内容等。</p>
<h3 id="索引和性能"><a href="#索引和性能" class="headerlink" title="索引和性能"></a>索引和性能</h3><p><strong>索引</strong>：BLOB和TEXT类型的列不能被索引，除非你指定一个前缀长度。例如：</p>
<p><strong>性能</strong>：由于BLOB和TEXT类型的数据可能非常大，它们的读写性能可能会受到影响。在设计数据库时，应尽量避免在这些字段上进行频繁的搜索和排序操作。</p>
<h3 id="存储和检索"><a href="#存储和检索" class="headerlink" title="存储和检索"></a>存储和检索</h3><p><strong>BLOB</strong>：存储和检索时不会进行字符集转换，适合存储二进制数据。</p>
<p><strong>TEXT</strong>：存储和检索时会进行字符集转换，适合存储需要字符集支持的文本数据。</p>
</blockquote>
<h1 id="什么是表分区"><a href="#什么是表分区" class="headerlink" title="什么是表分区"></a>什么是表分区</h1><blockquote>
<p>在MySQL中，表分区是一种将表的数据按照某种规则分成多个较小的独立部分（分区）的技术。每个分区可以独立存储在不同的文件或磁盘上，从而提高查询性能、简化管理和优化存储资源的利用。表分区特别适用于处理大型表的数据管理和查询优化。</p>
<h3 id="表分区的类型"><a href="#表分区的类型" class="headerlink" title="表分区的类型"></a>表分区的类型</h3><p>MySQL支持几种不同的分区方法，每种方法适用于不同的应用场景：</p>
<h4 id="范围分区（Range-Partitioning）"><a href="#范围分区（Range-Partitioning）" class="headerlink" title="范围分区（Range Partitioning）"></a>范围分区（Range Partitioning）</h4><p>根据列值的范围将数据分配到不同的分区。适用于日期或数值范围的分区。</p>
<p>例如，可以按年份、月份或其他数值范围进行分区。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  sale_date <span class="type">DATE</span>,</span><br><span class="line">  amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(sale_date)) (</span><br><span class="line">  <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> p2022 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2023</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> p2023 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2024</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="列表分区（List-Partitioning）"><a href="#列表分区（List-Partitioning）" class="headerlink" title="列表分区（List Partitioning）"></a>列表分区（List Partitioning）</h4><p>根据列值的具体列表将数据分配到不同的分区。适用于离散值的分区。</p>
<p>例如，可以按地区代码或类别进行分区。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  region_code <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> LIST (region_code) (</span><br><span class="line">  <span class="keyword">PARTITION</span> pNorth <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">&#x27;NA&#x27;</span>, <span class="string">&#x27;EU&#x27;</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> pSouth <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">&#x27;SA&#x27;</span>, <span class="string">&#x27;AF&#x27;</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> pEast <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">&#x27;AS&#x27;</span>, <span class="string">&#x27;OC&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="哈希分区（Hash-Partitioning）"><a href="#哈希分区（Hash-Partitioning）" class="headerlink" title="哈希分区（Hash Partitioning）"></a>哈希分区（Hash Partitioning）</h4><p>根据列值的哈希值将数据分配到不同的分区。适用于均匀分布数据的分区。</p>
<p>例如，可以使用主键或其他列的哈希值进行分区。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> logs (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  log_message TEXT</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> HASH (id) PARTITIONS <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<h4 id="键分区（Key-Partitioning）"><a href="#键分区（Key-Partitioning）" class="headerlink" title="键分区（Key Partitioning）"></a>键分区（Key Partitioning）</h4><p>类似于哈希分区，但使用MySQL内部的哈希函数。适用于需要更灵活的哈希分区策略。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  username <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> KEY (id) PARTITIONS <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<h3 id="复合分区（Composite-Partitioning）"><a href="#复合分区（Composite-Partitioning）" class="headerlink" title="复合分区（Composite Partitioning）"></a>复合分区（Composite Partitioning）</h3><p>结合两种分区方法，例如范围分区和哈希分区的组合。适用于更复杂的分区需求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  order_date <span class="type">DATE</span>,</span><br><span class="line">  customer_id <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(order_date))</span><br><span class="line">SUBPARTITION <span class="keyword">BY</span> HASH (customer_id) SUBPARTITIONS <span class="number">4</span> (</span><br><span class="line">  <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> p2022 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2023</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="表分区的优点"><a href="#表分区的优点" class="headerlink" title="表分区的优点"></a>表分区的优点</h3><p><strong>性能提升</strong>：通过将大表分成多个较小的分区，可以提高查询和操作的性能。查询可以在特定的分区上执行，减少了扫描的数据量。</p>
<p><strong>管理简化</strong>：分区表可以更容易地进行维护和管理，例如分区的添加、删除和归档。可以方便地进行备份和恢复操作。</p>
<p><strong>存储优化</strong>：不同的分区可以存储在不同的存储设备上，优化存储资源的利用。可以为不同的分区设置不同的存储引擎和参数。</p>
<p><strong>并行处理</strong>：分区表可以更好地利用并行处理能力，提高多线程查询的性能。</p>
<h3 id="使用表分区的注意事项"><a href="#使用表分区的注意事项" class="headerlink" title="使用表分区的注意事项"></a>使用表分区的注意事项</h3><h4 id="分区键的选择"><a href="#分区键的选择" class="headerlink" title="分区键的选择"></a>分区键的选择</h4><p>选择合适的分区键非常重要，直接影响查询和操作的性能。</p>
<p>分区键应当是查询中经常使用的列。</p>
<h4 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h4><p>定期维护分区，例如合并小分区、拆分大分区、归档历史数据等。</p>
</blockquote>
<h1 id="表分区与分表的区别"><a href="#表分区与分表的区别" class="headerlink" title="表分区与分表的区别"></a>表分区与分表的区别</h1><blockquote>
<h3 id="分区（Partitioning）"><a href="#分区（Partitioning）" class="headerlink" title="分区（Partitioning）"></a>分区（Partitioning）</h3><p>分区是将一个大表按照某种规则分成多个较小的部分，每个部分称为一个分区。这些分区在逻辑上仍然属于同一个表，但在物理上可以独立存储。</p>
<p><strong>实现方式</strong>：</p>
<p><strong>内部实现</strong>：分区是在数据库内部实现的，用户在查询或操作时不需要关注分区的存在。</p>
<p><strong>分区类型</strong>：MySQL支持多种分区类型，如范围分区、列表分区、哈希分区和键分区等。</p>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>查询优化</strong>：通过分区裁剪（Partition Pruning），查询可以只在相关的分区上执行，减少扫描的数据量。</li>
<li><strong>管理简化</strong>：可以方便地进行分区的添加、删除和归档等操作。</li>
<li><strong>并行处理</strong>：分区可以更好地利用并行处理能力，提高多线程查询的性能。</li>
<li><strong>存储优化</strong>：不同的分区可以存储在不同的存储设备上，优化存储资源的利用。</li>
</ol>
<h3 id="分表（Sharding）"><a href="#分表（Sharding）" class="headerlink" title="分表（Sharding）"></a>分表（Sharding）</h3><p>分表是将一个大表按照某种规则拆分成多个较小的表，每个表称为一个分片（Shard）。这些分片在逻辑上是独立的表，但在应用层面上被视为一个整体。</p>
<p><strong>实现方式</strong>：</p>
<p><strong>外部实现</strong>：分表通常需要在应用层面实现，应用程序需要知道数据如何分布在不同的表中。</p>
<p><strong>分片规则</strong>：分表的规则可以是基于某个列的范围、哈希值或者其他自定义规则。</p>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>水平扩展</strong>：分表可以将数据分布到多个数据库实例上，实现水平扩展。</li>
<li><strong>负载均衡</strong>：通过分表可以将负载均衡到不同的数据库实例上，减少单个实例的压力。</li>
<li><strong>独立管理</strong>：每个分片可以独立进行备份、恢复和优化等操作。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">分区</th>
<th style="text-align:center">分表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实现层面</td>
<td style="text-align:center">在数据库内部实现，用户透明。</td>
<td style="text-align:center">在应用层面实现，应用程序需要处理数据分布。</td>
</tr>
<tr>
<td style="text-align:center">管理复杂度</td>
<td style="text-align:center">管理相对简单，可以通过SQL语句直接操作分区。</td>
<td style="text-align:center">管理复杂，需要应用程序和数据库层面共同处理。</td>
</tr>
<tr>
<td style="text-align:center">性能优化</td>
<td style="text-align:center">通过分区裁剪和并行处理优化查询性能。</td>
<td style="text-align:center">通过将数据分布到多个实例上减少单个实例的负载。</td>
</tr>
<tr>
<td style="text-align:center">扩展性</td>
<td style="text-align:center">适用于单个数据库实例内的数据管理和性能优化。</td>
<td style="text-align:center">适用于跨多个数据库实例的水平扩展和负载均衡。</td>
</tr>
<tr>
<td style="text-align:center">适用场景</td>
<td style="text-align:center">适用于大表的数据管理和查询优化，特别是需要处理大量数据的单个数据库实例。</td>
<td style="text-align:center">适用于需要水平扩展和负载均衡的大规模分布式系统。</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<h1 id="什么情况下会产生死锁"><a href="#什么情况下会产生死锁" class="headerlink" title="什么情况下会产生死锁"></a>什么情况下会产生死锁</h1><blockquote>
<h3 id="不同顺序的锁定"><a href="#不同顺序的锁定" class="headerlink" title="不同顺序的锁定"></a>不同顺序的锁定</h3><p>当两个或多个事务以不同的顺序请求相同的资源时，容易引发死锁。</p>
<p>1、 事务A先锁定表1的记录，然后尝试锁定表2的记录。</p>
<p>2、 事务B先锁定表2的记录，然后尝试锁定表1的记录。</p>
<p>3、 如果事务A和事务B同时执行，就可能导致死锁。</p>
<h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><p>在InnoDB存储引擎中，间隙锁用于防止幻读。在范围查询中，间隙锁可能会导致死锁。</p>
<p>1、 事务A执行SELECT * FROM table WHERE id &gt; 10 FOR UPDATE，锁定了id大于10的所有记录及其间隙。</p>
<p>2、 事务B执行INSERT INTO table (id) VALUES (15)，试图插入一个新记录。</p>
<p>3、 如果这两个事务并发执行，可能会导致死锁。</p>
<h3 id="自增列的死锁"><a href="#自增列的死锁" class="headerlink" title="自增列的死锁"></a>自增列的死锁</h3><p>在高并发情况下，当多个事务同时插入自增列时，可能会导致死锁。</p>
<p>1、 事务A和事务B同时插入数据到包含自增主键的表中。</p>
<p>2、MySQL在分配自增值时可能会导致锁争用，从而引发死锁。</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>在涉及外键约束的表中，更新或删除操作可能会导致死锁。</p>
<p>1、 事务A在表1中删除一条记录，该表有一个外键引用表2。</p>
<p>2、 事务B在表2中更新或删除与表1中记录相关的记录。</p>
<p>3、 如果这两个事务并发执行，可能会导致死锁。</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>当MySQL从行级锁升级到表级锁时，可能会导致死锁。</p>
<p>1、 事务A和事务B分别锁定同一表中的不同行。</p>
<p>2、 如果某个操作需要将行级锁升级为表级锁，这可能会导致死锁。</p>
<h3 id="混合使用不同类型的锁"><a href="#混合使用不同类型的锁" class="headerlink" title="混合使用不同类型的锁"></a>混合使用不同类型的锁</h3><p>在同一个事务中混合使用不同类型的锁（如读锁和写锁）时，可能会导致死锁。</p>
<p>1、事务A持有一个读锁，并试图获取一个写锁。</p>
<p>2、事务B持有一个写锁，并试图获取一个读锁。</p>
<p>3、如果这两个事务并发执行，可能会导致死锁。</p>
<h3 id="大量并发事务"><a href="#大量并发事务" class="headerlink" title="大量并发事务"></a>大量并发事务</h3><p>在高并发环境中，大量事务同时操作同一资源，可能会导致死锁。</p>
<p>1、多个事务同时对同一行数据进行更新操作。</p>
<p>2、事务之间相互等待资源释放，可能会导致死锁。</p>
<h3 id="处理和预防死锁的方法"><a href="#处理和预防死锁的方法" class="headerlink" title="处理和预防死锁的方法"></a>处理和预防死锁的方法</h3><ol>
<li><strong>自动检测和回滚</strong>：InnoDB存储引擎能够自动检测死锁，并回滚其中一个事务以解除死锁。</li>
<li><strong>查看死锁信息</strong>：使用命令SHOW ENGINE INNODB STATUS查看最近一次死锁的信息，以帮助诊断问题。</li>
<li><strong>合理的事务设计</strong>：尽量避免长时间持有锁，确保事务尽可能短小和高效。</li>
<li><strong>一致的锁定顺序</strong>：确保所有事务以相同的顺序请求资源，以减少死锁的可能性。</li>
<li><strong>减少并发事务</strong>：通过优化应用程序逻辑，减少同时并发的事务数量。</li>
</ol>
</blockquote>
<h1 id="死锁常见解决方案"><a href="#死锁常见解决方案" class="headerlink" title="死锁常见解决方案"></a>死锁常见解决方案</h1><blockquote>
<p>MySQL中的死锁是指两个或多个事务相互等待对方持有的锁，从而导致这些事务无法继续执行。死锁是并发控制中的一个常见问题，特别是在高并发环境下。</p>
<h3 id="分析和优化SQL语句"><a href="#分析和优化SQL语句" class="headerlink" title="分析和优化SQL语句"></a>分析和优化SQL语句</h3><p><strong>减少锁的持有时间</strong>：优化SQL语句，使其执行时间更短，从而减少锁的持有时间，降低死锁发生的概率。</p>
<p><strong>避免大事务</strong>：将大事务拆分为多个小事务，减少每个事务持有锁的时间。</p>
<p><strong>索引优化</strong>：确保查询使用了合适的索引，减少全表扫描，从而减少锁冲突。</p>
<h3 id="调整事务的顺序"><a href="#调整事务的顺序" class="headerlink" title="调整事务的顺序"></a>调整事务的顺序</h3><p><strong>统一访问顺序</strong>：确保所有事务以相同的顺序访问资源。例如，如果多个事务都需要访问表A和表B，确保所有事务都先访问表A，再访问表B。</p>
<p><strong>减少循环等待</strong>：通过调整事务的执行顺序，避免事务之间形成循环等待。</p>
<h3 id="使用合适的隔离级别"><a href="#使用合适的隔离级别" class="headerlink" title="使用合适的隔离级别"></a>使用合适的隔离级别</h3><p><strong>降低隔离级别</strong>：在某些情况下，可以考虑使用较低的隔离级别（如READ COMMITTED）来减少锁冲突。但需要权衡数据一致性和并发性能。</p>
<p><strong>使用锁机制</strong>：在某些情况下，可以显式使用LOCK IN SHARE MODE或FOR UPDATE来控制锁的粒度和范围。</p>
<h3 id="合理使用索引"><a href="#合理使用索引" class="headerlink" title="合理使用索引"></a>合理使用索引</h3><p><strong>覆盖索引</strong>：使用覆盖索引（covering index）来减少锁的争用。例如，如果查询只需要访问索引列，可以避免访问数据行，从而减少锁冲突。</p>
<p><strong>避免索引缺失</strong>：确保查询使用了合适的索引，避免全表扫描导致的大量锁争用。</p>
<h3 id="监控和分析"><a href="#监控和分析" class="headerlink" title="监控和分析"></a>监控和分析</h3><p><strong>启用死锁日志</strong>：在MySQL配置中启用死锁日志，记录死锁信息以便分析。</p>
<p><strong>分析死锁日志</strong>：通过分析死锁日志，找出导致死锁的SQL语句和事务，进行针对性的优化。</p>
<h3 id="锁等待超时"><a href="#锁等待超时" class="headerlink" title="锁等待超时"></a>锁等待超时</h3><p><strong>设置合理的锁等待超时</strong>：通过设置合理的锁等待超时参数（如innodb_lock_wait_timeout），避免长时间等待锁，从而减少死锁影响。</p>
</blockquote>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><blockquote>
<p>视图（View）是SQL数据库中的一种虚拟表，它是基于SQL查询结果定义的。视图本身不存储数据，而是存储了一个SQL查询，当你访问视图时，数据库会执行该查询并返回结果。视图可以包含来自一个或多个表的列和行，并且可以包含过滤、排序、连接等复杂的SQL操作。</p>
<ol>
<li><strong>简化复杂查询</strong></li>
</ol>
<p>视图可以将复杂的SQL查询封装起来，使得用户在使用时只需简单地查询视图，避免重复编写复杂的SQL语句。</p>
<ol>
<li><strong>提高数据安全性</strong></li>
</ol>
<p>视图可以限制用户访问底层表中的敏感数据。例如，可以创建一个不包含敏感信息的视图，用户只能访问视图而不是底层表。</p>
<ol>
<li><strong>提供数据抽象</strong></li>
</ol>
<p>视图可以提供数据的不同视角，抽象出底层表的复杂性。例如，可以创建一个视图，将多个表的联合结果呈现为一个单一的逻辑表。</p>
<ol>
<li><strong>实现数据重用</strong></li>
</ol>
<p>视图可以被多个应用程序或用户重用，确保数据逻辑的一致性和可维护性。如果查询逻辑发生变化，只需修改视图定义，而不需要修改所有使用该查询的地方。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>视图的更新</strong>：并不是所有视图都可以更新。只有满足一定条件（如视图基于单个表，没有聚合函数等）的视图才可以进行插入、更新和删除操作。</p>
<p><strong>性能影响</strong>：视图本身不存储数据，每次访问视图时都会执行底层查询。如果视图定义的查询非常复杂，可能会影响性能。</p>
<p><strong>依赖管理</strong>：视图依赖于底层表结构，如果底层表结构发生变化（如列名更改、表删除等），视图也需要相应调整。</p>
<h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h3><p>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</p>
<p>视图是由基本表(实表)产生的表(虚表)。</p>
<p>视图的建立和删除不影响基本表。</p>
<p>对视图内容的更新(添加，删除和修改)直接影响基本表。</p>
<p>当视图来自多个基本表时，不允许添加和删除数据。</p>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>
<p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，是不可修改的</p>
</blockquote>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><blockquote>
<p>存储过程（Stored Procedure）是数据库中一组预编译的SQL语句和控制结构的集合，可以在数据库中保存并执行。存储过程可以包含逻辑控制、循环、条件判断等复杂的逻辑，并且可以接受参数和返回结果。存储过程的主要目的是将业务逻辑封装在数据库层，以提高性能和简化应用程序的实现。</p>
<h3 id="创建存储过程的基本语法"><a href="#创建存储过程的基本语法" class="headerlink" title="创建存储过程的基本语法"></a>创建存储过程的基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> procedure_name (<span class="keyword">IN</span> parameter1 datatype, <span class="keyword">OUT</span> parameter2 datatype, <span class="keyword">INOUT</span> parameter3 datatype)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- SQL 语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> increase_salary(<span class="keyword">IN</span> emp_id <span class="type">INT</span>, <span class="keyword">IN</span> increment <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> employees</span><br><span class="line">    <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> increment</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<h3 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h3><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p><strong>预编译</strong>：存储过程在首次执行时会被编译，并存储在数据库中，后续执行时无需再次编译，减少了解析和优化的开销。</p>
<p><strong>权限控制</strong>：可以通过设置存储过程的执行权限，限制用户直接访问底层表，只允许通过存储过程进行操作。</p>
<p><strong>隐藏复杂逻辑</strong>：存储过程可以封装复杂的业务逻辑，用户无需了解具体实现细节。</p>
<p><strong>封装业务逻辑</strong>：将常用的业务逻辑封装在存储过程内，多个应用程序可以重用这些逻辑，减少代码重复。</p>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p><strong>调试工具有限</strong>：与应用程序代码相比，存储过程的调试工具和方法较为有限，调试和排错较为困难。</p>
<p><strong>错误处理复杂</strong>：存储过程中的错误处理通常比应用程序代码中的错误处理更复杂。</p>
<p><strong>数据库依赖性</strong>：存储过程通常依赖于特定数据库的语法和功能，不同数据库之间的存储过程可能无法直接移植。</p>
<p><strong>资源消耗</strong>：存储过程在数据库服务器上执行，可能会占用大量服务器资源，导致性能瓶颈。</p>
</blockquote>
<h1 id="union和union-all区别"><a href="#union和union-all区别" class="headerlink" title="union和union all区别"></a>union和union all区别</h1><blockquote>
<p>UNION和UNION ALL是 SQL 中用于合并两个或多个结果集的操作符。它们的主要区别在于是否去除重复的行。</p>
<p> <strong>UNION</strong> </p>
<p>去除重复行：UNION操作会自动去除合并结果中的重复行。</p>
<p>排序操作：由于UNION需要去除重复行，因此它会在内部执行一个排序操作来识别和删除重复行，这可能会影响性能。</p>
<p><strong>UNION ALL</strong><br>保留重复行：UNION ALL操作不会去除重复行，所有的结果行都会被保留。<br>性能较好：由于UNION ALL不需要进行去重操作，因此通常比UNION性能更好，特别是在处理大数据量时。</p>
</blockquote>
<h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><blockquote>
<p>MySQL 的二进制日志（binlog）是一个重要的日志文件，用于记录对数据库进行的所有更改操作。二进制日志的主要功能包括数据恢复、复制和审计。</p>
<h2 id="二进制日志的作用"><a href="#二进制日志的作用" class="headerlink" title="二进制日志的作用"></a>二进制日志的作用</h2><p><strong>数据恢复</strong>：在发生崩溃或数据丢失时，可以使用二进制日志恢复数据。通过重放日志中的更改，可以将数据库恢复到某个时间点。</p>
<p><strong>复制</strong>：二进制日志是 MySQL 复制机制的基础。主服务器（master）将其上的所有更改记录到二进制日志中，从服务器（slave）通过读取这些日志来复制数据变化，从而保持数据同步。</p>
<p><strong>审计和分析</strong>：二进制日志可以用来审计数据库上的更改操作，帮助管理员了解谁在何时对数据库进行了哪些更改。</p>
<h2 id="二进制日志的组成"><a href="#二进制日志的组成" class="headerlink" title="二进制日志的组成"></a>二进制日志的组成</h2><p>二进制日志由多个日志文件组成，这些文件按照顺序记录了所有的更改操作。每个日志文件都有一个唯一的编号，MySQL 会自动轮换和生成新的日志文件。</p>
<h2 id="配置和管理二进制日志"><a href="#配置和管理二进制日志" class="headerlink" title="配置和管理二进制日志"></a>配置和管理二进制日志</h2><ol>
<li><strong>启用二进制日志</strong>：在 MySQL 配置文件（通常是<code>my.cnf</code>或<code>my.ini</code>）中，添加以下配置项以启用二进制日志：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>查看二进制日志状态</strong>：使用以下 SQL 命令查看二进制日志的状态：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure>
<p>查看当前正在使用的二进制日志文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> MASTER STATUS;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>管理二进制日志</strong>：手动刷新二进制日志文件：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH LOGS;</span><br></pre></td></tr></table></figure>
<p>删除旧的二进制日志文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PURGE <span class="type">BINARY</span> LOGS <span class="keyword">TO</span> <span class="string">&#x27;mysql-bin.000010&#x27;</span>;</span><br><span class="line">或</span><br><span class="line">PURGE <span class="type">BINARY</span> LOGS BEFORE <span class="string">&#x27;2024-01-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>配置二进制日志保留策略</strong>：可以在配置文件中设置保留策略，例如自动删除7天前的二进制日志：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">expire_logs_days <span class="operator">=</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h3 id="解析二进制日志"><a href="#解析二进制日志" class="headerlink" title="解析二进制日志"></a>解析二进制日志</h3><p>MySQL 提供了<code>mysqlbinlog</code>工具，用于读取和解析二进制日志文件。以下是一些常用的命令：</p>
<ol>
<li><strong>显示二进制日志内容</strong>：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog mysql<span class="operator">-</span>bin<span class="number">.000001</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>将二进制日志内容导入数据库</strong>：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> mysql <span class="operator">-</span>u username <span class="operator">-</span>p</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h1><blockquote>
<p>MySQL 的重做日志（redo log）是 InnoDB 存储引擎中的一个关键组件，用于保证数据的持久性和一致性。重做日志记录了所有对数据库进行的修改操作，这些操作在实际写入数据文件之前先写入重做日志。</p>
<h2 id="重做日志的作用"><a href="#重做日志的作用" class="headerlink" title="重做日志的作用"></a>重做日志的作用</h2><ol>
<li><strong>数据恢复</strong>：在数据库崩溃或意外关机时，重做日志可以用于恢复未完成的事务。通过重做日志，InnoDB 可以在重新启动时重新应用未完成的事务，确保数据的一致性。</li>
<li><strong>提高性能</strong>：重做日志的存在使得 InnoDB 可以将事务提交的更改快速写入日志文件，而不是立即写入数据文件。这种机制减少了磁盘 I/O 操作，提高了数据库的性能。</li>
</ol>
<h2 id="重做日志的工作原理"><a href="#重做日志的工作原理" class="headerlink" title="重做日志的工作原理"></a>重做日志的工作原理</h2><ol>
<li><strong>写入重做日志</strong>：当一个事务开始时，所有的修改操作都会首先记录到内存中的重做日志缓存（redo log buffer）。当事务提交时，重做日志缓存中的内容会被刷新到磁盘上的重做日志文件中，以确保事务的持久性。</li>
<li><strong>重做日志应用</strong>：在数据库重启时，InnoDB 会检查重做日志文件中的内容，并重新应用所有未完成的事务。这一过程称为“重做（redo）”。</li>
</ol>
<h2 id="重做日志的组成"><a href="#重做日志的组成" class="headerlink" title="重做日志的组成"></a>重做日志的组成</h2><p>重做日志由一组固定大小的日志文件组成，这些文件循环使用。具体配置项包括：</p>
<ol>
<li><strong>重做日志文件路径和大小</strong>：可以在 MySQL 配置文件（<code>my.cnf</code>或<code>my.ini</code>）中设置重做日志文件的路径和大小：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_log_group_home_dir <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>  # 重做日志文件的存储路径</span><br><span class="line">innodb_log_file_size <span class="operator">=</span> <span class="number">512</span>M  # 每个重做日志文件的大小</span><br><span class="line">innodb_log_files_in_group <span class="operator">=</span> <span class="number">2</span>  # 重做日志文件的数量</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>重做日志缓冲区大小</strong>：设置重做日志缓冲区的大小：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_log_buffer_size <span class="operator">=</span> <span class="number">16</span>M</span><br></pre></td></tr></table></figure>
<h2 id="管理重做日志"><a href="#管理重做日志" class="headerlink" title="管理重做日志"></a>管理重做日志</h2><ol>
<li><strong>查看重做日志状态</strong>：可以通过以下命令查看重做日志的状态：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>调整重做日志配置</strong>：调整重做日志文件的大小和数量需要先关闭 MySQL 服务，删除现有的重做日志文件，然后重新启动 MySQL 服务。具体步骤如下：</li>
</ol>
<p>关闭 MySQL 服务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop mysql</span><br></pre></td></tr></table></figure>
<p>删除现有的重做日志文件（通常位于数据目录中，例如/var/lib/mysql）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>ib_logfile<span class="operator">*</span></span><br></pre></td></tr></table></figure>
<p>修改 MySQL 配置文件中的重做日志设置。</p>
<p>重新启动 MySQL 服务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">start</span> mysql</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="其他的什么log"><a href="#其他的什么log" class="headerlink" title="其他的什么log"></a>其他的什么log</h1><blockquote>
<h3 id="错误日志（Error-Log）"><a href="#错误日志（Error-Log）" class="headerlink" title="错误日志（Error Log）"></a>错误日志（Error Log）</h3><p>记录 MySQL 服务器启动、运行和停止期间发生的错误和重要事件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_error <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>error.log</span><br></pre></td></tr></table></figure>
<p>错误日志可以通过查看配置的日志文件来检查，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>error.log</span><br></pre></td></tr></table></figure>
<h3 id="查询日志（General-Query-Log）"><a href="#查询日志（General-Query-Log）" class="headerlink" title="查询日志（General Query Log）"></a>查询日志（General Query Log）</h3><p>记录所有客户端连接和执行的 SQL 语句。这对于调试和审计非常有用，但由于记录了所有查询，可能会对性能产生影响。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">general_log_file <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>query.log</span><br></pre></td></tr></table></figure>
<p>查询日志可以通过查看配置的日志文件来检查</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>query.log</span><br></pre></td></tr></table></figure>
<h3 id="慢查询日志（Slow-Query-Log）"><a href="#慢查询日志（Slow-Query-Log）" class="headerlink" title="慢查询日志（Slow Query Log）"></a>慢查询日志（Slow Query Log）</h3><p>记录执行时间超过指定阈值的查询。这对于优化性能和识别慢查询非常有用。</p>
<p>可以在 MySQL 配置文件中启用慢查询日志并设置日志文件路径和阈值时间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">slow_query_log_file <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span>  # 记录执行时间超过 <span class="number">2</span> 秒的查询</span><br></pre></td></tr></table></figure>
<p>慢查询日志可以通过查看配置的日志文件来检查</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br></pre></td></tr></table></figure>
<h3 id="中继日志（Relay-Log）-1"><a href="#中继日志（Relay-Log）-1" class="headerlink" title="中继日志（Relay Log）"></a>中继日志（Relay Log）</h3><p>在 MySQL 复制环境中，从服务器（slave）使用中继日志记录从主服务器（master）接收到的二进制日志事件。中继日志用于应用这些事件以保持数据同步。</p>
<h3 id="事务日志（Undo-Log）"><a href="#事务日志（Undo-Log）" class="headerlink" title="事务日志（Undo Log）"></a>事务日志（Undo Log）</h3><p>记录事务的撤销操作，用于支持事务的回滚和 MVCC（多版本并发控制）。撤销日志通常是 InnoDB 存储引擎的一部分。</p>
<h3 id="表空间日志（Tablespace-Log）"><a href="#表空间日志（Tablespace-Log）" class="headerlink" title="表空间日志（Tablespace Log）"></a>表空间日志（Tablespace Log）</h3><p>记录表空间的扩展、收缩等操作。主要用于管理 InnoDB 的物理存储。</p>
<p>表空间日志由 InnoDB 自动管理，通常不需要手动配置。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://WYH-7.github.io">WYH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wyh-7.github.io/posts/54e1373e.html">http://wyh-7.github.io/posts/54e1373e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://WYH-7.github.io" target="_blank">WYH</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a></div><div class="post_share"><div class="social-share" data-image="https://images.pexels.com/photos/346529/pexels-photo-346529.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b7e144d1.html" title="算法模板"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/933054/pexels-photo-933054.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法模板</div></div></a></div><div class="next-post pull-right"><a href="/posts/d87f7e0c.html" title="测试文章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/547115/pexels-photo-547115.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">测试文章</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/66c016fb.html" title="JVM面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/618833/pexels-photo-618833.jpeg?auto=compress&cs=tinysrgb&w=600" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="title">JVM面试题</div></div></a></div><div><a href="/posts/da3e1361.html" title="Mybatis面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/933054/pexels-photo-933054.jpeg?auto=compress&cs=tinysrgb&w=600" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-16</div><div class="title">Mybatis面试题</div></div></a></div><div><a href="/posts/186242d5.html" title="MQ面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/933054/pexels-photo-933054.jpeg?auto=compress&cs=tinysrgb&w=600" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-21</div><div class="title">MQ面试题</div></div></a></div><div><a href="/posts/6c92115f.html" title="Spring面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/640781/pexels-photo-640781.jpeg?auto=compress&cs=tinysrgb&w=600" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="title">Spring面试题</div></div></a></div><div><a href="/posts/bae4ff13.html" title="Redis面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/346529/pexels-photo-346529.jpeg?auto=compress&cs=tinysrgb&w=600" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="title">Redis面试题</div></div></a></div><div><a href="/posts/1bb262db.html" title="简历八股文"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/552785/pexels-photo-552785.jpeg?auto=compress&cs=tinysrgb&w=600" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="title">简历八股文</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WYH</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">事务的四大特性和隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">原子性（Atomicity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88Consistency%EF%BC%89"><span class="toc-number">1.0.2.</span> <span class="toc-text">一致性（Consistency）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88Isolation%EF%BC%89"><span class="toc-number">1.0.3.</span> <span class="toc-text">隔离性（Isolation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88Durability%EF%BC%89"><span class="toc-number">1.0.4.</span> <span class="toc-text">持久性（Durability）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyISAM%E4%B8%8EInnoDB%E5%8C%BA%E5%88%AB%E5%8F%8A%E9%80%89%E6%8B%A9"><span class="toc-number">2.</span> <span class="toc-text">MyISAM与InnoDB区别及选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.1.</span> <span class="toc-text">数据存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81"><span class="toc-number">2.0.2.</span> <span class="toc-text">事务支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">2.0.3.</span> <span class="toc-text">锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E6%94%AF%E6%8C%81"><span class="toc-number">2.0.4.</span> <span class="toc-text">外键支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">2.0.5.</span> <span class="toc-text">全文索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">2.0.6.</span> <span class="toc-text">存储空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="toc-number">2.0.7.</span> <span class="toc-text">表的大小限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">2.0.8.</span> <span class="toc-text">如何选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94hash%E7%B4%A2%E5%BC%95"><span class="toc-number">3.</span> <span class="toc-text">自适应hash索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.0.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.0.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">4.</span> <span class="toc-text">Mysql使用规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">4.0.1.</span> <span class="toc-text">数据库设计规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">4.0.2.</span> <span class="toc-text">索引设计规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83"><span class="toc-number">4.0.3.</span> <span class="toc-text">SQL编写规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="toc-number">4.0.4.</span> <span class="toc-text">数据类型选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.0.5.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.0.6.</span> <span class="toc-text">安全管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%97%A5%E5%BF%97"><span class="toc-number">4.0.7.</span> <span class="toc-text">监控与日志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">5.</span> <span class="toc-text">建立索引需要考虑的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%88%97"><span class="toc-number">5.0.1.</span> <span class="toc-text">选择合适的列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="toc-number">5.0.2.</span> <span class="toc-text">索引覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.0.3.</span> <span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">5.0.4.</span> <span class="toc-text">复合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%A8%80%E7%96%8F%E6%80%A7"><span class="toc-number">5.0.5.</span> <span class="toc-text">索引的稀疏性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E4%B8%8E%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="toc-number">5.0.6.</span> <span class="toc-text">系统资源与性能影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">5.0.7.</span> <span class="toc-text">评估和优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">数据库的三范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F-1NF"><span class="toc-number">6.0.1.</span> <span class="toc-text">第一范式 (1NF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F-2NF"><span class="toc-number">6.0.2.</span> <span class="toc-text">第二范式 (2NF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F-3NF"><span class="toc-number">6.0.3.</span> <span class="toc-text">第三范式 (3NF)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E7%9A%84explain%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">Mysql的explain有哪些列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#idM"><span class="toc-number">7.0.1.</span> <span class="toc-text">idM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-type"><span class="toc-number">7.0.2.</span> <span class="toc-text">select_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table"><span class="toc-number">7.0.3.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partitions"><span class="toc-number">7.0.4.</span> <span class="toc-text">partitions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-%E9%87%8D%E7%82%B9"><span class="toc-number">7.0.5.</span> <span class="toc-text">type(重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#possible-keys"><span class="toc-number">7.0.6.</span> <span class="toc-text">possible_keys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key"><span class="toc-number">7.0.7.</span> <span class="toc-text">key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-len"><span class="toc-number">7.0.8.</span> <span class="toc-text">key_len</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-number">7.0.9.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rows"><span class="toc-number">7.0.10.</span> <span class="toc-text">rows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filtered"><span class="toc-number">7.0.11.</span> <span class="toc-text">filtered</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extra"><span class="toc-number">7.0.12.</span> <span class="toc-text">Extra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">7.0.13.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-EXPLAIN-%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.0.14.</span> <span class="toc-text">使用 EXPLAIN 分析查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPLAIN-%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.0.15.</span> <span class="toc-text">EXPLAIN 输出示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-EXPLAIN-%E8%BE%93%E5%87%BA"><span class="toc-number">7.0.16.</span> <span class="toc-text">分析 EXPLAIN 输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orders-%E8%A1%A8%E6%89%AB%E6%8F%8F%EF%BC%88o-%E8%A1%A8%EF%BC%89"><span class="toc-number">7.0.17.</span> <span class="toc-text">orders 表扫描（o 表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#customers-%E8%A1%A8%E6%89%AB%E6%8F%8F%EF%BC%88c-%E8%A1%A8%EF%BC%89"><span class="toc-number">7.0.18.</span> <span class="toc-text">customers 表扫描（c 表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">7.0.19.</span> <span class="toc-text">优化建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84-EXPLAIN-%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.0.20.</span> <span class="toc-text">优化后的 EXPLAIN 输出示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">7.0.21.</span> <span class="toc-text">结果分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orders-%E8%A1%A8%E6%89%AB%E6%8F%8F%EF%BC%88o-%E8%A1%A8%EF%BC%89-1"><span class="toc-number">7.0.22.</span> <span class="toc-text">orders 表扫描（o 表）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E8%AF%AD%E5%8F%A5%E7%A7%8D%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">Mysql语句种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80-DDL"><span class="toc-number">8.0.1.</span> <span class="toc-text">数据定义语言 (DDL)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80-DML"><span class="toc-number">8.0.2.</span> <span class="toc-text">数据操作语言 (DML)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80-DCL"><span class="toc-number">8.0.3.</span> <span class="toc-text">数据控制语言 (DCL)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80-TCL"><span class="toc-number">8.0.4.</span> <span class="toc-text">事务控制语言 (TCL)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80-DQL"><span class="toc-number">8.0.5.</span> <span class="toc-text">数据查询语言 (DQL)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">8.0.6.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">Mysql查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">9.0.1.</span> <span class="toc-text">避免全表扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D-NULL-%E5%80%BC%E5%88%A4%E6%96%AD"><span class="toc-number">9.0.2.</span> <span class="toc-text">避免 NULL 值判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D-%E6%88%96-lt-gt-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">9.0.3.</span> <span class="toc-text">避免 !&#x3D; 或 &lt;&gt; 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D-OR-%E6%9D%A1%E4%BB%B6"><span class="toc-number">9.0.4.</span> <span class="toc-text">避免 OR 条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-IN-%E5%92%8C-NOT-IN"><span class="toc-number">9.0.5.</span> <span class="toc-text">谨慎使用 IN 和 NOT IN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIKE-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">9.0.6.</span> <span class="toc-text">LIKE 查询优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2%E5%AF%BC%E8%87%B4%E7%9A%84%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">9.0.7.</span> <span class="toc-text">避免参数化查询导致的全表扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">9.0.8.</span> <span class="toc-text">避免表达式操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-EXISTS-%E6%9B%BF%E4%BB%A3-IN"><span class="toc-number">9.0.9.</span> <span class="toc-text">使用 EXISTS 替代 IN</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">10.</span> <span class="toc-text">Mysql聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">10.0.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">10.0.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">10.0.3.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%A6%81%E9%80%89%E6%8B%A9%E9%A2%91%E7%B9%81%E6%9B%B4%E6%96%B0%E7%9A%84%E5%88%97"><span class="toc-number">11.</span> <span class="toc-text">聚集索引不要选择频繁更新的列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8E%92"><span class="toc-number">11.0.1.</span> <span class="toc-text">数据重排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%88%86%E8%A3%82%E5%92%8C%E5%90%88%E5%B9%B6"><span class="toc-number">11.0.2.</span> <span class="toc-text">页分裂和合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%B4%E6%8A%A4"><span class="toc-number">11.0.3.</span> <span class="toc-text">二级索引的维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E4%BA%89%E7%94%A8%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-number">11.0.4.</span> <span class="toc-text">锁争用和死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">12.</span> <span class="toc-text">Mysql非聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">12.0.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">12.0.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">12.0.3.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E7%9A%84%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">13.</span> <span class="toc-text">Mysql的回表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">13.0.1.</span> <span class="toc-text">回表查询的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">13.0.2.</span> <span class="toc-text">回表查询的步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E7%9A%84%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">14.</span> <span class="toc-text">Mysql的覆盖索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">14.0.1.</span> <span class="toc-text">索引覆盖的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-Demo"><span class="toc-number">14.0.2.</span> <span class="toc-text">示例 Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">14.0.3.</span> <span class="toc-text">使用覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">14.0.4.</span> <span class="toc-text">覆盖索引的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.0.5.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">15.</span> <span class="toc-text">Mysql前缀索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">15.0.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7"><span class="toc-number">15.0.2.</span> <span class="toc-text">索引选择性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">15.0.3.</span> <span class="toc-text">如何创建前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">15.0.4.</span> <span class="toc-text">前缀索引的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">15.0.5.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">15.0.6.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">15.0.7.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E4%B8%8D%E5%BB%BA%E6%88%96%E5%B0%91%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">16.</span> <span class="toc-text">什么情况下应不建或少建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BE%83%E5%B0%8F"><span class="toc-number">16.0.1.</span> <span class="toc-text">表的数据量较小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E9%A2%91%E7%B9%81"><span class="toc-number">16.0.2.</span> <span class="toc-text">表的写操作频繁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E5%9F%BA%E6%95%B0%E4%BD%8E"><span class="toc-number">16.0.3.</span> <span class="toc-text">索引列的基数低</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD"><span class="toc-number">16.0.4.</span> <span class="toc-text">频繁的批量数据加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%BC%8F%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%88%96%E5%A4%9A%E5%8F%98"><span class="toc-number">16.0.5.</span> <span class="toc-text">查询模式不确定或多变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%BF%87%E5%A4%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BB%B4%E6%8A%A4%E5%BC%80%E9%94%80"><span class="toc-number">16.0.6.</span> <span class="toc-text">索引过多导致的维护开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E7%9A%84%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">16.0.7.</span> <span class="toc-text">使用不当的复合索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">17.</span> <span class="toc-text">Mysql常见索引失效的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%88%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">17.0.1.</span> <span class="toc-text">使用函数或表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">17.0.2.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8OR%E6%9D%A1%E4%BB%B6"><span class="toc-number">17.0.3.</span> <span class="toc-text">使用OR条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="toc-number">17.0.4.</span> <span class="toc-text">前导模糊查询：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E%E6%93%8D%E4%BD%9C"><span class="toc-number">17.0.5.</span> <span class="toc-text">不等于操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%90%8E%E5%86%8D%E4%BD%BF%E7%94%A8%E7%AD%89%E5%80%BC%E6%9D%A1%E4%BB%B6"><span class="toc-number">17.0.6.</span> <span class="toc-text">范围条件后再使用等值条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%BB%A1%E8%B6%B3%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-number">17.0.7.</span> <span class="toc-text">不满足最左前缀原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E8%B4%9F%E5%90%91%E6%9F%A5%E8%AF%A2"><span class="toc-number">17.0.8.</span> <span class="toc-text">查询条件中包含负向查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E5%8C%80"><span class="toc-number">17.0.9.</span> <span class="toc-text">数据分布不均匀</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E6%AF%94%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%BF%AB%E5%90%97"><span class="toc-number">18.</span> <span class="toc-text">唯一索引比普通索引快吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.0.1.</span> <span class="toc-text">唯一索引与普通索引的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD"><span class="toc-number">18.0.2.</span> <span class="toc-text">查询性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E6%9B%B4%E6%96%B0%E6%80%A7%E8%83%BD"><span class="toc-number">18.0.3.</span> <span class="toc-text">插入和更新性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">18.0.4.</span> <span class="toc-text">删除操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#A-B-C%E4%B8%89%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%BB%84%E6%88%90%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%8CAB-AC-BC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%90%A6%E8%83%BD%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">A,B,C三个字段组成联合索引，AB,AC,BC三种情况下查询是否能命中索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">19.0.1.</span> <span class="toc-text">联合索引的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90"><span class="toc-number">19.0.2.</span> <span class="toc-text">查询情况分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%BA-A-B"><span class="toc-number">19.0.2.1.</span> <span class="toc-text">1. 查询条件为(A, B)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%BA-A-C"><span class="toc-number">19.0.2.2.</span> <span class="toc-text">2. 查询条件为(A, C)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%BA-B-C"><span class="toc-number">19.0.2.3.</span> <span class="toc-text">3. 查询条件为(B, C)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E6%83%85%E5%86%B5"><span class="toc-number">19.0.3.</span> <span class="toc-text">其他查询情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%BA-A"><span class="toc-number">19.0.3.1.</span> <span class="toc-text">4. 查询条件为(A)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%BA-B"><span class="toc-number">19.0.3.2.</span> <span class="toc-text">5. 查询条件为(B)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%BA-A-B-C"><span class="toc-number">19.0.3.3.</span> <span class="toc-text">6. 查询条件为(A, B, C)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">B+树索引和哈希索引的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">20.0.1.</span> <span class="toc-text">B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">20.0.1.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">20.0.2.</span> <span class="toc-text">哈希索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">20.0.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">20.0.2.2.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">20.0.3.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4B-%E6%AF%94B%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">为什么说B+比B树更适合实际应用中作为数据库索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-number">21.0.1.</span> <span class="toc-text">范围查询效率更高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E7%A3%81%E7%9B%98I-O%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-number">21.0.2.</span> <span class="toc-text">内存和磁盘I&#x2F;O效率更高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%9B%B4%E4%BD%8E%E3%80%81%E6%9B%B4%E5%9D%87%E5%8C%80"><span class="toc-number">21.0.3.</span> <span class="toc-text">树的高度更低、更均匀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E9%80%82%E5%90%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">21.0.4.</span> <span class="toc-text">更适合数据库的插入和删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E9%AB%98%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">21.0.5.</span> <span class="toc-text">更高的空间利用率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">22.</span> <span class="toc-text">Mysql分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%EF%BC%88Vertical-Sharding%EF%BC%89"><span class="toc-number">22.0.1.</span> <span class="toc-text">垂直分表（Vertical Sharding）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%EF%BC%88Horizontal-Sharding%EF%BC%89"><span class="toc-number">22.0.2.</span> <span class="toc-text">水平分表（Horizontal Sharding）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">22.0.3.</span> <span class="toc-text">分库分表联合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">22.0.4.</span> <span class="toc-text">实现注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">23.</span> <span class="toc-text">mysql主从同步原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Master%EF%BC%89"><span class="toc-number">23.0.1.</span> <span class="toc-text">主服务器（Master）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%EF%BC%88Binary-Log%EF%BC%89"><span class="toc-number">23.0.2.</span> <span class="toc-text">二进制日志（Binary Log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Slave%EF%BC%89"><span class="toc-number">23.0.3.</span> <span class="toc-text">从服务器（Slave）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97%EF%BC%88Relay-Log%EF%BC%89"><span class="toc-number">23.0.4.</span> <span class="toc-text">中继日志（Relay Log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">23.0.5.</span> <span class="toc-text">复制过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%94%B9%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">23.0.5.1.</span> <span class="toc-text">1、 主服务器记录更改到二进制日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%BB%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">23.0.5.2.</span> <span class="toc-text">2、从服务器读取二进制日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97"><span class="toc-number">23.0.5.3.</span> <span class="toc-text">3、从服务器应用中继日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BF%83%E8%B7%B3%E6%A3%80%E6%9F%A5"><span class="toc-number">23.0.5.4.</span> <span class="toc-text">4、心跳检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE"><span class="toc-number">23.0.6.</span> <span class="toc-text">复制如何配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">23.0.6.1.</span> <span class="toc-text">配置主服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">23.0.6.2.</span> <span class="toc-text">配置从服务器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">24.</span> <span class="toc-text">mysql主从同步延迟的原因和解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">24.0.1.</span> <span class="toc-text">延迟原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">24.0.2.</span> <span class="toc-text">解决办法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E7%9A%84%E5%85%A8%E5%A4%8D%E5%88%B6%E3%80%81%E5%8D%8A%E5%A4%8D%E5%88%B6%E3%80%81%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">25.</span> <span class="toc-text">mysql的全复制、半复制、异步复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">25.0.1.</span> <span class="toc-text">异步复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">25.0.1.1.</span> <span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">25.0.2.</span> <span class="toc-text">半同步复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">25.0.2.1.</span> <span class="toc-text">工作原理：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">25.0.3.</span> <span class="toc-text">全同步复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="toc-number">25.0.3.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">25.0.3.2.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#drop-delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">drop,delete与truncate的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DROP"><span class="toc-number">26.0.1.</span> <span class="toc-text">DROP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">26.0.1.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DELETE"><span class="toc-number">26.0.2.</span> <span class="toc-text">DELETE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-number">26.0.2.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TRUNCATE"><span class="toc-number">26.0.3.</span> <span class="toc-text">TRUNCATE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-6"><span class="toc-number">26.0.3.1.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6MVCC"><span class="toc-number">27.</span> <span class="toc-text">多版本并发控制MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">27.0.1.</span> <span class="toc-text">MVCC 的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">27.0.2.</span> <span class="toc-text">MVCC 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">27.0.3.</span> <span class="toc-text">MVCC 的实现细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVCC%E4%BD%9C%E7%94%A8"><span class="toc-number">28.</span> <span class="toc-text">MVCC作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7"><span class="toc-number">28.0.1.</span> <span class="toc-text">提高并发性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%94%81%E4%BA%89%E7%94%A8"><span class="toc-number">28.0.2.</span> <span class="toc-text">减少锁争用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%86%E5%9B%BE"><span class="toc-number">28.0.3.</span> <span class="toc-text">提供一致性视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%AF%BB%E5%86%99%E5%86%B2%E7%AA%81"><span class="toc-number">28.0.4.</span> <span class="toc-text">避免读写冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E6%AD%BB%E9%94%81"><span class="toc-number">28.0.5.</span> <span class="toc-text">减少死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E8%AF%BB%E6%80%A7%E8%83%BD"><span class="toc-number">28.0.6.</span> <span class="toc-text">提高读性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9B%B4%E9%AB%98%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">28.0.7.</span> <span class="toc-text">实现更高的隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99"><span class="toc-number">28.0.7.1.</span> <span class="toc-text">场景 1：高并发读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E9%81%BF%E5%85%8D%E8%AF%BB%E5%86%99%E5%86%B2%E7%AA%81"><span class="toc-number">28.0.7.2.</span> <span class="toc-text">场景 2：避免读写冲突</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81"><span class="toc-number">29.</span> <span class="toc-text">MySQL中有哪几种锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%EF%BC%88Table-Locks%EF%BC%89"><span class="toc-number">29.0.1.</span> <span class="toc-text">表级锁（Table Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%EF%BC%88Row-Locks%EF%BC%89"><span class="toc-number">29.0.2.</span> <span class="toc-text">行级锁（Row Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="toc-number">29.0.3.</span> <span class="toc-text">间隙锁（Gap Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Intention-Locks%EF%BC%89"><span class="toc-number">29.0.4.</span> <span class="toc-text">意向锁（Intention Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%88Auto-Increment-Locks%EF%BC%89"><span class="toc-number">29.0.5.</span> <span class="toc-text">自增锁（Auto-Increment Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88Metadata-Locks%EF%BC%89"><span class="toc-number">29.0.6.</span> <span class="toc-text">元数据锁（Metadata Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E9%94%81%EF%BC%88Foreign-Key-Locks%EF%BC%89"><span class="toc-number">29.0.7.</span> <span class="toc-text">外键锁（Foreign Key Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E9%94%81%EF%BC%88Temporary-Locks%EF%BC%89"><span class="toc-number">29.0.8.</span> <span class="toc-text">临时锁（Temporary Locks）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">30.</span> <span class="toc-text">Mysql的常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">30.0.1.</span> <span class="toc-text">字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">30.0.2.</span> <span class="toc-text">数值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0"><span class="toc-number">30.0.3.</span> <span class="toc-text">日期和时间函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">30.0.4.</span> <span class="toc-text">聚合函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">30.0.5.</span> <span class="toc-text">其他常用函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.</span> <span class="toc-text">Mysql的常用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.1.</span> <span class="toc-text">数值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.1.1.</span> <span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.1.2.</span> <span class="toc-text">浮点数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.1.3.</span> <span class="toc-text">定点数类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.2.</span> <span class="toc-text">字符串类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.3.</span> <span class="toc-text">二进制类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.4.</span> <span class="toc-text">日期和时间类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.5.</span> <span class="toc-text">JSON 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.6.</span> <span class="toc-text">枚举和集合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">31.0.7.</span> <span class="toc-text">特殊类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E7%9A%84char%E5%92%8Cvarchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">32.</span> <span class="toc-text">Mysql的char和varchar的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">32.0.1.</span> <span class="toc-text">存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%95%88%E7%8E%87"><span class="toc-number">32.0.2.</span> <span class="toc-text">存储效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">32.0.3.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">32.0.4.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E4%B8%ADint-1-%E5%92%8Cint-10-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">33.</span> <span class="toc-text">mysql中int(1)和int(10)的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="toc-number">33.0.1.</span> <span class="toc-text">数值范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%AE%BD%E5%BA%A6"><span class="toc-number">33.0.2.</span> <span class="toc-text">显示宽度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D"><span class="toc-number">33.0.3.</span> <span class="toc-text">影响</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#blob%E5%92%8Ctext%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">34.</span> <span class="toc-text">blob和text的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9"><span class="toc-number">34.0.1.</span> <span class="toc-text">存储内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-number">34.0.2.</span> <span class="toc-text">类型和大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-number">34.0.3.</span> <span class="toc-text">字符集和排序规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">34.0.4.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E6%80%A7%E8%83%BD"><span class="toc-number">34.0.5.</span> <span class="toc-text">索引和性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%92%8C%E6%A3%80%E7%B4%A2"><span class="toc-number">34.0.6.</span> <span class="toc-text">存储和检索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A8%E5%88%86%E5%8C%BA"><span class="toc-number">35.</span> <span class="toc-text">什么是表分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">35.0.1.</span> <span class="toc-text">表分区的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA%EF%BC%88Range-Partitioning%EF%BC%89"><span class="toc-number">35.0.1.1.</span> <span class="toc-text">范围分区（Range Partitioning）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%86%E5%8C%BA%EF%BC%88List-Partitioning%EF%BC%89"><span class="toc-number">35.0.1.2.</span> <span class="toc-text">列表分区（List Partitioning）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%EF%BC%88Hash-Partitioning%EF%BC%89"><span class="toc-number">35.0.1.3.</span> <span class="toc-text">哈希分区（Hash Partitioning）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E5%88%86%E5%8C%BA%EF%BC%88Key-Partitioning%EF%BC%89"><span class="toc-number">35.0.1.4.</span> <span class="toc-text">键分区（Key Partitioning）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%88%86%E5%8C%BA%EF%BC%88Composite-Partitioning%EF%BC%89"><span class="toc-number">35.0.2.</span> <span class="toc-text">复合分区（Composite Partitioning）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">35.0.3.</span> <span class="toc-text">表分区的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%88%86%E5%8C%BA%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">35.0.4.</span> <span class="toc-text">使用表分区的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E9%94%AE%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">35.0.4.1.</span> <span class="toc-text">分区键的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">35.0.4.2.</span> <span class="toc-text">分区管理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E4%B8%8E%E5%88%86%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">36.</span> <span class="toc-text">表分区与分表的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%EF%BC%88Partitioning%EF%BC%89"><span class="toc-number">36.0.1.</span> <span class="toc-text">分区（Partitioning）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%EF%BC%88Sharding%EF%BC%89"><span class="toc-number">36.0.2.</span> <span class="toc-text">分表（Sharding）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-number">37.</span> <span class="toc-text">什么情况下会产生死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%94%81%E5%AE%9A"><span class="toc-number">37.0.1.</span> <span class="toc-text">不同顺序的锁定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89"><span class="toc-number">37.0.2.</span> <span class="toc-text">间隙锁（Gap Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E5%88%97%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">37.0.3.</span> <span class="toc-text">自增列的死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-number">37.0.4.</span> <span class="toc-text">外键约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">37.0.5.</span> <span class="toc-text">锁升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%81"><span class="toc-number">37.0.6.</span> <span class="toc-text">混合使用不同类型的锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1"><span class="toc-number">37.0.7.</span> <span class="toc-text">大量并发事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%92%8C%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">37.0.8.</span> <span class="toc-text">处理和预防死锁的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">38.</span> <span class="toc-text">死锁常见解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%92%8C%E4%BC%98%E5%8C%96SQL%E8%AF%AD%E5%8F%A5"><span class="toc-number">38.0.1.</span> <span class="toc-text">分析和优化SQL语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">38.0.2.</span> <span class="toc-text">调整事务的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">38.0.3.</span> <span class="toc-text">使用合适的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">38.0.4.</span> <span class="toc-text">合理使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%92%8C%E5%88%86%E6%9E%90"><span class="toc-number">38.0.5.</span> <span class="toc-text">监控和分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6"><span class="toc-number">38.0.6.</span> <span class="toc-text">锁等待超时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">39.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">39.0.1.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-7"><span class="toc-number">39.0.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="toc-number">39.0.3.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">40.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">40.0.1.</span> <span class="toc-text">创建存储过程的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">40.0.2.</span> <span class="toc-text">存储过程的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-number">40.0.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="toc-number">40.0.4.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#union%E5%92%8Cunion-all%E5%8C%BA%E5%88%AB"><span class="toc-number">41.</span> <span class="toc-text">union和union all区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binlog"><span class="toc-number">42.</span> <span class="toc-text">binlog</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">42.1.</span> <span class="toc-text">二进制日志的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">42.2.</span> <span class="toc-text">二进制日志的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">42.3.</span> <span class="toc-text">配置和管理二进制日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">42.3.1.</span> <span class="toc-text">解析二进制日志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redolog"><span class="toc-number">43.</span> <span class="toc-text">redolog</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">43.1.</span> <span class="toc-text">重做日志的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">43.2.</span> <span class="toc-text">重做日志的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">43.3.</span> <span class="toc-text">重做日志的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="toc-number">43.4.</span> <span class="toc-text">管理重做日志</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E4%BB%80%E4%B9%88log"><span class="toc-number">44.</span> <span class="toc-text">其他的什么log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%88Error-Log%EF%BC%89"><span class="toc-number">44.0.1.</span> <span class="toc-text">错误日志（Error Log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88General-Query-Log%EF%BC%89"><span class="toc-number">44.0.2.</span> <span class="toc-text">查询日志（General Query Log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88Slow-Query-Log%EF%BC%89"><span class="toc-number">44.0.3.</span> <span class="toc-text">慢查询日志（Slow Query Log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97%EF%BC%88Relay-Log%EF%BC%89-1"><span class="toc-number">44.0.4.</span> <span class="toc-text">中继日志（Relay Log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%EF%BC%88Undo-Log%EF%BC%89"><span class="toc-number">44.0.5.</span> <span class="toc-text">事务日志（Undo Log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%97%A5%E5%BF%97%EF%BC%88Tablespace-Log%EF%BC%89"><span class="toc-number">44.0.6.</span> <span class="toc-text">表空间日志（Tablespace Log）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/bae4ff13.html" title="Redis面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/346529/pexels-photo-346529.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis面试题"/></a><div class="content"><a class="title" href="/posts/bae4ff13.html" title="Redis面试题">Redis面试题</a><time datetime="2025-04-28T07:31:37.000Z" title="发表于 2025-04-28 15:31:37">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/186242d5.html" title="MQ面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/933054/pexels-photo-933054.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MQ面试题"/></a><div class="content"><a class="title" href="/posts/186242d5.html" title="MQ面试题">MQ面试题</a><time datetime="2025-04-21T13:27:37.000Z" title="发表于 2025-04-21 21:27:37">2025-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c35f27cb.html" title="算法（java）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/31133725/pexels-photo-31133725.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600&amp;lazy=load" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法（java）"/></a><div class="content"><a class="title" href="/posts/c35f27cb.html" title="算法（java）">算法（java）</a><time datetime="2025-04-18T14:03:29.000Z" title="发表于 2025-04-18 22:03:29">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/da3e1361.html" title="Mybatis面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/933054/pexels-photo-933054.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis面试题"/></a><div class="content"><a class="title" href="/posts/da3e1361.html" title="Mybatis面试题">Mybatis面试题</a><time datetime="2025-04-16T05:57:37.000Z" title="发表于 2025-04-16 13:57:37">2025-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6c92115f.html" title="Spring面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.pexels.com/photos/640781/pexels-photo-640781.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring面试题"/></a><div class="content"><a class="title" href="/posts/6c92115f.html" title="Spring面试题">Spring面试题</a><time datetime="2025-04-15T14:28:51.000Z" title="发表于 2025-04-15 22:28:51">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By WYH</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.6534116,27.96920845';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/./js/runtime/runtime.js"></script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"scriptFremo":"local","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","with":150,"heigth":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>